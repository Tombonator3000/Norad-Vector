<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"/>
<title>NORAD Vector - Enhanced Edition</title>
<link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
<style>
:root{
  --bg:#050a14;
  --cyan:#00ffff; --green:#00ff00; --mag:#ff00ff; --amber:#ffaa00; --yellow:#ffff00; --red:#ff0000;
  --panel:rgba(0,18,34,.85);
  --glow-cyan:0 0 20px rgba(0,255,255,0.8);
  --glow-green:0 0 20px rgba(0,255,0,0.8);
  --glow-mag:0 0 20px rgba(255,0,255,0.8);

  /* Primary font variable.  Changing this value at runtime via
     `applyFont()` allows the user to select between retro monospace,
     sans‑serif and modern typefaces.  The body element references
     --font-main, so fallback is applied if the variable is absent. */
  --font-main: 'Courier New', monospace;
}
/* Responsive adjustments for mobile screens. When the viewport width is below 768px,
   rearrange HUD panels vertically and shrink fonts to accommodate smaller devices. */
@media (max-width: 768px) {
  body {
    font-size: 14px;
    overflow-y: auto;
  }
  .hud {
    height: auto;
    flex-direction: column;
    align-items: flex-start;
    padding: 6px;
  }
  .hud-left, .hud-center, .hud-right {
    flex-direction: row;
    flex-wrap: wrap;
    width: 100%;
    justify-content: space-between;
    margin-bottom: 6px;
  }
  #resourcePanel, #doomsdayPanel, #scorePanel, #statusPanel, #log {
    width: 100%;
    margin-bottom: 8px;
    overflow-x: auto;
  }
  .modal-content {
    max-width: 95%;
  }
  .start-menu button {
    font-size: 14px;
    padding: 6px 12px;
  }
}

/* Themes */
.synthwave{
  /* Restore the original synthwave palette.  The Tron‑inspired colours were too intense; this
     palette uses softer neon tones for better readability. */
  --bg:#050a14;
  --cyan:#8fe1ff;
  --green:#aaff99;
  --mag:#ff79c6;
  --amber:#ffb15a;
  --yellow:#ffe66d;
  --red:#ff5555;
}
.retro80s{
  --bg:#001122;
  --cyan:#00ff41; --green:#39ff14; --mag:#ff0080; --amber:#ffaa00; --yellow:#ffff00; --red:#ff2020;
}
.wargames{
  --bg:#000000;
  --cyan:#00ff00; --green:#00ff00; --mag:#ff0000; --amber:#ffff00; --yellow:#ffffff; --red:#ff0000;
  --font-main:'Press Start 2P', monospace;
}

/* Pixelated rendering for retro themes.  Applying image‑rendering on the 
   canvases for these themes gives a crisp, blocky aesthetic reminiscent of 
   early computer graphics. */
.retro80s canvas,
.wargames canvas {
  image-rendering: pixelated;
}

/* High contrast theme: blacks for backgrounds and bright, high contrast
   colours for on‑screen elements.  This palette dramatically
   improves readability for visually impaired players and those in
   bright environments. */
.highcontrast{
  --bg:#000000;
  --cyan:#ffffff;
  --green:#ffff00;
  --mag:#ff00ff;
  --amber:#ff8800;
  --yellow:#ffff00;
  --red:#ff0000;
  --panel:rgba(0,0,0,0.9);
}

/* Night mode theme: deep blues and muted neons to reduce eye strain in
   low‑light conditions.  Colours are desaturated and the background
   darkened for comfortable play after dark. */
.nightmode{
  --bg:#010a14;
  --cyan:#66ccff;
  --green:#88cc88;
  --mag:#cc88cc;
  --amber:#cc9966;
  --yellow:#cccc66;
  --red:#cc6666;
  --panel:rgba(0,16,32,0.85);
}

/* Tutorial highlight: applies an outline and gentle glow to elements
   that are being explained in the interactive tutorial. */
.tutorial-highlight{
  outline:2px dashed var(--yellow);
  box-shadow:0 0 10px 5px rgba(255,255,0,0.5);
  position:relative;
  z-index:10000;
}

/* Tutorial overlay container.  This is dynamically positioned near
   the element being described.  It contains the instructional text
   and navigation buttons. */
.tutorial-overlay{
  position:absolute;
  max-width:280px;
  background:rgba(0,0,0,0.85);
  border:2px solid var(--cyan);
  padding:12px;
  z-index:10001;
  color:var(--cyan);
  font-size:12px;
  line-height:1.3;
  pointer-events:auto;
}

/* Urgent event panel.  When a global disaster strikes, this panel
   appears centred on screen with a call‑to‑action. */
#urgentEvent{
  position:fixed;
  top:0;left:0;right:0;bottom:0;
  display:none;
  align-items:center;
  justify-content:center;
  background:rgba(0,0,0,0.8);
  z-index:6000;
}
#urgentEvent .event-box{
  background:rgba(0,0,0,0.95);
  border:2px solid var(--red);
  padding:20px;
  max-width:320px;
  color:var(--red);
  text-align:center;
  box-shadow:0 0 30px var(--red);
}
#urgentEvent .event-box h3{
  margin-bottom:10px;
  font-size:18px;
  text-transform:uppercase;
  color:var(--yellow);
}
#urgentEvent .event-box p{
  font-size:12px;
  margin:10px 0;
}
#urgentEvent .event-box button{
  margin-top:10px;
  background:transparent;
  border:1px solid var(--cyan);
  color:var(--cyan);
  padding:6px 14px;
  cursor:pointer;
  font-size:12px;
  transition:all 0.2s;
}
#urgentEvent .event-box button:hover{
  background:rgba(0,255,255,0.1);
  box-shadow:0 0 15px var(--cyan);
}

/* Event card overlay.  This modal sits above most UI layers to
   summarise random events or other significant occurrences.  The
   card-box contains an optional image, title, description and a
   close button. */
#eventCard{
  position:fixed;
  top:0;left:0;right:0;bottom:0;
  display:none;
  align-items:center;
  justify-content:center;
  background:rgba(0,0,0,0.8);
  z-index:5500;
}
#eventCard .card-box{
  background:rgba(0,0,0,0.95);
  border:2px solid var(--amber);
  padding:20px;
  max-width:360px;
  width:90%;
  color:var(--cyan);
  text-align:center;
  box-shadow:0 0 30px var(--amber);
  position:relative;
}
#eventCard .card-box .card-image{
  width:100%;
  height:150px;
  object-fit:cover;
  margin-bottom:10px;
  border-bottom:1px solid var(--amber);
}
#eventCard .card-box .card-title{
  font-size:18px;
  color:var(--yellow);
  margin-bottom:6px;
  text-transform:uppercase;
  text-shadow:0 0 10px var(--yellow);
}
#eventCard .card-box .card-desc{
  font-size:12px;
  margin:10px 0;
  color:var(--cyan);
  line-height:1.4;
}
#eventCard .card-box .card-close-btn{
  margin-top:10px;
  background:transparent;
  border:1px solid var(--cyan);
  color:var(--cyan);
  padding:6px 14px;
  cursor:pointer;
  font-size:12px;
  transition:all 0.2s;
}
#eventCard .card-box .card-close-btn:hover{
  background:rgba(0,255,255,0.1);
  box-shadow:0 0 15px var(--cyan);
}

/* A small X button for closing modals.  Positioned in the top-right corner
   of the modal content.  When hovered, its colour changes to indicate
   interactivity. */
.modal-close{
  position:absolute;
  top:8px;
  right:10px;
  background:transparent;
  border:0;
  color:var(--cyan);
  font-size:18px;
  cursor:pointer;
}
.modal-close:hover{
  color:var(--yellow);
}

*{box-sizing:border-box;margin:0;padding:0}
html,body{height:100%;overflow:hidden}
/* Apply the main font variable so players can change typefaces at runtime.
   Fallbacks preserve the original retro monospace look. */
body{background:var(--bg);color:#00ffff;font-family:var(--font-main, 'Courier New', monospace)}

/* CRT Effect for retro themes */
.retro-crt {
  filter: blur(0.5px) contrast(1.2);
  background: radial-gradient(ellipse at center, transparent 60%, rgba(0,0,0,0.2) 100%);
}

/* Main Canvas */
#gameCanvas{position:absolute;inset:0;z-index:1}
#startCanvas{position:absolute;inset:0;z-index:1}

/* Background layers */
#bgGrid{position:absolute;inset:0;z-index:0}
#scan{position:absolute;inset:0;pointer-events:none;z-index:2;
  background-image: linear-gradient(to bottom, rgba(255,255,255,.06) 1px, rgba(0,0,0,0) 1px);
  background-size: 100% 3px;
  mix-blend-mode: overlay; opacity:.25;
}

/* HUD Top Bar */
.hud{
  position:absolute;
  top:0;left:0;right:0;
  height:48px;
  display:flex;
  align-items:center;
  justify-content:space-between;
  padding:4px 12px;
  background:rgba(0,0,0,0.8);
  border-bottom:2px solid var(--cyan);
  z-index:100;
  box-shadow:0 2px 20px rgba(0,255,255,0.3);
}

.hud-left{display:flex;gap:10px;align-items:center}
.hud-center{display:flex;gap:6px;align-items:center;flex:1;justify-content:center}
.hud-right{display:flex;gap:6px;align-items:center}

/* DEFCON Display */
.defcon-display{
  background:rgba(0,0,0,0.9);
  border:2px solid var(--cyan);
  padding:4px 12px;
  font-size:14px;
  font-weight:bold;
  text-shadow:0 0 10px var(--cyan);
  animation:pulse 2s infinite;
}
.defcon-display.alert{
  border-color:var(--red);
  color:var(--red);
  animation:alert-pulse 0.5s infinite;
}
@keyframes alert-pulse{
  0%,100%{opacity:1}
  50%{opacity:0.5}
}

/* DEFCON glow classes */
.defcon5{color:#b3f0ff;text-shadow:0 0 10px #58d0ff}
.defcon4{color:#d2ffe3;text-shadow:0 0 10px #83ffb0}
.defcon3{color:#ffe66d;text-shadow:0 0 10px #ffe66d}
.defcon2{color:#ffb15a;text-shadow:0 0 14px #ffb15a; animation:warn 1.2s infinite}
.defcon1{color:#ff5555;text-shadow:0 0 16px #ff5555; animation:warn 0.8s infinite}
@keyframes warn{50%{filter:brightness(1.3)}}

/* Buttons */
.btn{
  background:transparent;
  border:1px solid var(--cyan);
  color:var(--cyan);
  padding:4px 10px;
  cursor:pointer;
  font-size:11px;
  font-family:inherit;
  text-transform:uppercase;
  transition:all 0.2s;
}
.btn:hover{
  background:rgba(0,255,255,0.1);
  box-shadow:0 0 15px var(--cyan);
  transform:translateY(-1px);
}
.btn:active{transform:translateY(0)}
.btn:disabled{opacity:0.3;cursor:not-allowed}

/* Resources Panel */
.resources{
  position:absolute;
  top:58px;
  left:10px;
  background:var(--panel);
  border:1px solid var(--cyan);
  padding:8px;
  font-size:11px;
  z-index:50;
  min-width:160px;
}
.resource-row{
  display:flex;
  justify-content:space-between;
  padding:2px 0;
  color:var(--cyan);
}

/* Doomsday Clock */
.doomsday{
  position:absolute;
  top:58px;
  right:10px;
  background:rgba(0,0,0,0.9);
  border:2px solid var(--red);
  padding:10px;
  text-align:center;
  z-index:50;
  min-width:180px;
  box-shadow:0 0 30px rgba(255,0,0,0.5);
}
.doomsday-title{
  color:var(--red);
  font-size:10px;
  text-transform:uppercase;
  letter-spacing:2px;
  text-shadow:0 0 10px var(--red);
}
.doomsday-time{
  color:#fff;
  font-size:28px;
  font-weight:bold;
  text-shadow:0 0 15px var(--red);
  margin:5px 0;
}

/* Nation Status */
.nation-status{
  position:absolute;
  bottom:10px;
  right:10px;
  width:340px;
  background:var(--panel);
  border:2px solid var(--cyan);
  padding:10px;
  font-size:11px;
  z-index:50;
  box-shadow:0 0 20px rgba(0,255,255,0.3);
}
.nation-status h3{
  color:var(--cyan);
  font-size:14px;
  text-transform:uppercase;
  letter-spacing:2px;
  margin-bottom:8px;
  text-shadow:0 0 10px var(--cyan);
}
.status-row{
  display:flex;
  justify-content:space-between;
  padding:3px 0;
  border-bottom:1px solid rgba(0,255,255,0.2);
}
.status-row span:first-child{
  color:var(--green);
  text-transform:uppercase;
}
.status-row span:last-child{
  color:var(--cyan);
}

/* Log */
.log{
  position:absolute;
  bottom:10px;
  left:10px;
  right:360px;
  height:120px;
  background:var(--panel);
  border:1px solid var(--cyan);
  padding:8px;
  font-size:10px;
  overflow-y:auto;
  z-index:50;
  font-family:monospace;
  box-shadow:0 0 20px rgba(0,255,255,0.2);
}
.log-entry{
  padding:2px 0;
  color:var(--cyan);
  border-bottom:1px solid rgba(0,255,255,0.1);
}
.log-entry.warning{color:var(--amber)}
.log-entry.alert{color:var(--red)}
.log-entry.success{color:var(--green)}
.log-entry.banter{color:#ff79c6;font-weight:600}

/* Alert indicators */
.alert-radiation{animation:radPulse 1s infinite}
.alert-emp{animation:empGlitch 0.5s infinite}
@keyframes radPulse{0%,100%{color:#aaff99}50%{color:#ffff00}}
@keyframes empGlitch{0%{transform:translateX(0)}25%{transform:translateX(-2px)}75%{transform:translateX(2px)}100%{transform:translateX(0)}}

/* Scoreboard */
.scoreboard{
  position:absolute;
  top:58px;
  left:180px;
  background:var(--panel);
  border:1px solid var(--cyan);
  padding:8px;
  font-size:10px;
  z-index:50;
  min-width:200px;
}
.scoreboard h4{
  color:var(--green);
  font-size:11px;
  margin-bottom:5px;
  text-transform:uppercase;
}
.score-entry{
  display:flex;
  justify-content:space-between;
  padding:2px 0;
  color:var(--cyan);
}

/* Modal */
#modal{
  position:fixed;
  inset:0;
  background:rgba(0,0,0,0.9);
  backdrop-filter:blur(4px);
  display:none;
  align-items:center;
  justify-content:center;
  z-index:5000;
}
.modal-content{
  background:rgba(0,0,0,0.95);
  border:2px solid var(--mag);
  padding:20px;
  min-width:400px;
  max-width:90vw;
  max-height:80vh;
  overflow-y:auto;
  box-shadow:0 0 50px var(--mag);
}
.modal-title{
  color:var(--mag);
  font-size:16px;
  margin-bottom:15px;
  text-transform:uppercase;
  letter-spacing:2px;
  text-shadow:0 0 10px var(--mag);
}
.modal-grid{
  display:grid;
  grid-template-columns:repeat(auto-fit,minmax(200px,1fr));
  gap:10px;
  margin:15px 0;
}
.modal-btn{
  background:rgba(255,0,255,0.1);
  border:1px solid var(--mag);
  color:var(--mag);
  padding:10px;
  cursor:pointer;
  font-family:inherit;
  font-size:11px;
  text-align:left;
  transition:all 0.2s;
}
.modal-btn:hover{
  background:rgba(255,0,255,0.2);
  box-shadow:0 0 20px var(--mag);
  transform:translateY(-2px);
}
.modal-btn:disabled{
  opacity:0.4;
  cursor:not-allowed;
  color: #888;
}
.modal-btn strong{
  display:block;
  color:#fff;
  margin-bottom:4px;
}
.modal-btn small{
  opacity:0.8;
  font-size:10px;
}

/* Start Screen */
#start{
  position:fixed;
  inset:0;
  background:#000;
  display:flex;
  align-items:center;
  justify-content:center;
  z-index:2000;
}
.start-content{
  text-align:center;
  z-index:10;
  animation:fadeIn 1s;
}
.start-title{
  font-size:64px;
  color:var(--cyan);
  text-shadow:0 0 40px var(--cyan);
  letter-spacing:6px;
  margin:0;
  animation:glow 2s ease-in-out infinite;
}
@keyframes glow{
  0%,100%{text-shadow:0 0 40px var(--cyan)}
  50%{text-shadow:0 0 60px var(--cyan),0 0 80px var(--cyan)}
}
.start-subtitle{
  color:var(--green);
  font-size:18px;
  margin:20px 0;
  letter-spacing:3px;
  text-shadow:0 0 20px var(--green);
}
.start-menu{
  margin:40px 0;
}
.start-btn{
  background:transparent;
  border:2px solid var(--cyan);
  color:var(--cyan);
  padding:15px 40px;
  margin:10px;
  font-size:16px;
  font-family:inherit;
  cursor:pointer;
  text-transform:uppercase;
  letter-spacing:2px;
  transition:all 0.3s;
}
.start-btn:hover{
  background:rgba(0,255,255,0.1);
  box-shadow:0 0 30px var(--cyan);
  transform:scale(1.05);
}

/* Leader Selection */
.leader-grid{
  display:grid;
  grid-template-columns:repeat(5,1fr);
  gap:15px;
  margin:30px auto;
  max-width:900px;
}
.leader-card{
  background:rgba(0,255,255,0.05);
  border:2px solid var(--cyan);
  padding:15px;
  cursor:pointer;
  transition:all 0.3s;
  text-align:center;
}
.leader-card:hover{
  background:rgba(0,255,255,0.15);
  box-shadow:0 0 25px var(--cyan);
  transform:translateY(-5px);
}
.leader-name{
  color:var(--cyan);
  font-weight:bold;
  font-size:13px;
  margin-bottom:5px;
}
.leader-ai{
  color:var(--green);
  font-size:11px;
  text-transform:uppercase;
}

/* Doctrine Cards */
.doctrine-grid{
  display:grid;
  grid-template-columns:repeat(3,1fr);
  gap:15px;
  margin:30px auto;
  max-width:900px;
}
.doctrine-card{
  background:rgba(255,0,255,0.05);
  border:2px solid var(--mag);
  padding:15px;
  cursor:pointer;
  transition:all 0.3s;
}
.doctrine-card:hover{
  background:rgba(255,0,255,0.15);
  box-shadow:0 0 25px var(--mag);
  transform:translateY(-5px);
}
.doctrine-name{
  color:var(--mag);
  font-weight:bold;
  font-size:14px;
  margin-bottom:5px;
}
.doctrine-desc{
  color:#fff;
  font-size:11px;
  margin-bottom:5px;
  font-style:italic;
}
.doctrine-effects{
  color:var(--green);
  font-size:10px;
}

/* End Game */
#endGame{
  position:fixed;
  inset:0;
  background:rgba(0,0,0,0.95);
  display:none;
  align-items:center;
  justify-content:center;
  z-index:2000;
}
.end-content{
  text-align:center;
  padding:40px;
  border:3px solid var(--red);
  background:rgba(20,0,0,0.9);
  box-shadow:0 0 50px var(--red);
}
.end-title{
  font-size:48px;
  color:var(--red);
  text-shadow:0 0 40px var(--red);
  margin:0 0 20px 0;
  animation:pulse 1s infinite;
}
@keyframes pulse{
  0%,100%{opacity:1}
  50%{opacity:0.7}
}

/* Phase Badge */
#phaseBadge{
  position:absolute;
  left:16px;
  top:60px;
  padding:6px 10px;
  border-radius:8px;
  background:#222a;
  backdrop-filter: blur(2px);
  color:#fff;
  font:600 12px/1.2 system-ui;
  letter-spacing:.5px;
  z-index:5;
}

/* Animations */
@keyframes fadeIn{
  from{opacity:0}
  to{opacity:1}
}
@keyframes scanline{
  0%{transform:translateY(-100%)}
  100%{transform:translateY(100%)}
}

/* Mobile layout */
@media (max-width: 900px){
  .hud{height:48px;padding:4px 6px;flex-wrap:wrap}
  .btn{padding:4px 8px;font-size:11px;margin:2px}
  .hud-left{font-size:10px}
  .hud-center{flex-wrap:wrap;gap:3px}
  
  .nation-status{
    left:8px;
    right:8px;
    bottom:8px;
    top:auto;
    height:140px;
    width:auto;
  }
  
  .log{
    left:8px;
    right:8px;
    bottom:156px;
    height:100px;
  }
  
  .resources, .doomsday, .scoreboard {
    font-size:10px;
    padding:6px;
  }
}
</style>
</head>
<body class="synthwave">

<!-- Background Layers -->
<canvas id="bgGrid"></canvas>
<div id="scan"></div>

<!-- Phase Badge -->
<div id="phaseBadge">PHASE: PLAYER</div>

<!-- HUD -->
<div class="hud" id="gameHud" style="display:none">
  <div class="hud-left">
    <div class="defcon-display" id="defconPill">DEFCON <span id="defcon">5</span></div>
    <div style="color:var(--cyan);font-size:12px">TURN <span id="turn">1</span></div>
    <div style="color:var(--cyan);font-size:12px">ACTIONS: <span id="actionsDisplay">1/1</span></div>
  </div>
  <div class="hud-center">
    <button class="btn" id="actBuild">BUILD</button>
    <button class="btn" id="actResearch">RESEARCH</button>
    <button class="btn" id="actIntel">INTEL</button>
    <button class="btn" id="actCulture">CULTURE</button>
    <button class="btn" id="actImmigration">IMMIGRATION</button>
    <button class="btn" id="actDiplomacy">DIPLOMACY</button>
    <button class="btn" id="actAttack">ATTACK</button>
    <button class="btn" id="turnBtn" style="border-color:var(--mag);color:var(--mag)">END TURN</button>
  </div>
  <div class="hud-right">
    <button class="btn" id="pauseBtn">||</button>
    <button class="btn" id="saveBtn">SAVE</button>
    <button class="btn" id="fullscreenBtn" title="Toggle Fullscreen">⛶</button>
    <button class="btn" id="optionsBtn">⚙</button>
  </div>
</div>

<!-- Urgent event overlay.  Hidden by default; shown when a time‑critical
     global disaster occurs.  The inner .event-box contains the
     title, description and respond button populated by
     showUrgentEvent(). -->
<div id="urgentEvent">
  <div class="event-box">
    <h3 id="urgentTitle">Event</h3>
    <p id="urgentMessage">Something happens</p>
    <button id="urgentRespondBtn">RESPOND</button>
  </div>
</div>

<!-- Event card overlay.  Displays a summary of random events or special
     occurrences in a stylised card with optional image.  Users can
     disable event cards in the options menu. -->
<div id="eventCard">
  <div class="card-box">
    <img class="card-image" src="" alt="event image" style="display:none" />
    <h3 class="card-title">Event</h3>
    <p class="card-desc">An event has occurred.</p>
    <button class="card-close-btn">CLOSE</button>
  </div>
</div>

<!-- Resources -->
<div class="resources" id="resourcePanel" style="display:none">
  <div class="resource-row"><span>PRODUCTION:</span><span id="productionDisplay">0</span></div>
  <div class="resource-row"><span>URANIUM:</span><span id="uraniumDisplay">0</span></div>
  <div class="resource-row"><span>INTEL:</span><span id="intelDisplay">0</span></div>
  <div class="resource-row"><span>CITIES:</span><span id="citiesDisplay">1</span></div>
  <div class="resource-row"><span>POPULATION:</span><span id="popDisplay">100</span></div>
</div>

<!-- Doomsday Clock -->
<div class="doomsday" id="doomsdayPanel" style="display:none">
  <div class="doomsday-title">DOOMSDAY CLOCK</div>
  <div class="doomsday-time" id="doomsdayTime">7:00</div>
  <div style="font-size:10px;color:#ff9999">Minutes to Midnight</div>
</div>

<!-- Scoreboard -->
<div class="scoreboard" id="scorePanel" style="display:none">
  <h4>NATIONS</h4>
  <div id="scoreList"></div>
</div>

<!-- Nation Status -->
<div class="nation-status" id="statusPanel" style="display:none">
  <h3>NATION STATUS</h3>
  <div class="status-row"><span>Leader:</span><span id="leaderDisplay">—</span></div>
  <div class="status-row"><span>Doctrine:</span><span id="doctrineDisplay">—</span></div>
  <div class="status-row"><span>Missiles:</span><span id="missileDisplay">—</span></div>
  <div class="status-row"><span>Bombers:</span><span id="bomberDisplay">—</span></div>
  <div class="status-row"><span>Defense:</span><span id="defenseDisplay">—</span></div>
  <div class="status-row"><span>Instability:</span><span id="instabilityDisplay">—</span></div>
  <div class="status-row"><span>Warheads:</span><span id="warheadDisplay">—</span></div>
  <div class="status-row"><span>Submarines:</span><span id="submarineDisplay">—</span></div>
  <div id="hazardDisplay"></div>
</div>

<!-- Log -->
<div class="log" id="log" style="display:none"></div>

<!-- Game Canvas -->
<canvas id="gameCanvas"></canvas>

<!-- Start Screen -->
<div id="start">
  <canvas id="startCanvas"></canvas>
  <div class="start-content">
    <h1 class="start-title">NORAD VECTOR</h1>
    <div class="start-subtitle">SHALL WE PLAY A GAME?</div>
    <div class="start-menu">
      <button class="start-btn" id="newGameBtn">NEW GAME</button>
      <button class="start-btn" id="continueBtn" style="display:none">CONTINUE</button>
      <button class="start-btn" id="startOptionsBtn">OPTIONS</button>
      <button class="start-btn" id="highscoresBtn">HIGHSCORES</button>
      <!-- Tutorial button added for a comprehensive rules and how-to-play guide -->
      <button class="start-btn" id="tutorialBtn">HOW TO PLAY</button>
    </div>
    <div id="leaderSelect" style="display:none">
      <h3 style="color:var(--cyan);margin:20px 0;text-transform:uppercase">Select Leader</h3>
      <div class="leader-grid" id="leaderGrid"></div>
    </div>
    <div id="doctrineSelect" style="display:none">
      <h3 style="color:var(--mag);margin:20px 0;text-transform:uppercase">Select Doctrine</h3>
      <div class="doctrine-grid" id="doctrineGrid"></div>
    </div>
    <div id="difficultySelect" style="display:none">
      <h3 style="color:var(--green);margin:20px 0;text-transform:uppercase">Select Difficulty</h3>
      <div style="display:flex;justify-content:center;gap:20px">
        <button class="start-btn" onclick="startGame('easy')">EASY</button>
        <button class="start-btn" onclick="startGame('normal')">NORMAL</button>
        <button class="start-btn" onclick="startGame('hard')">HARD</button>
      </div>
    </div>
  </div>
</div>

<!-- Modal -->
<div id="modal">
  <div class="modal-content">
    <button id="modalCloseX" class="modal-close" aria-label="Close">×</button>
    <h3 class="modal-title" id="modalTitle">TITLE</h3>
    <div id="modalBody"></div>
    <div style="margin-top:15px">
      <button class="btn" onclick="closeModal()" style="padding:8px 20px">CLOSE [ESC]</button>
    </div>
  </div>
</div>

<!-- End Game -->
<div id="endGame">
  <div class="end-content">
    <h1 class="end-title" id="endTitle">GAME OVER</h1>
    <div id="endText" style="color:#fff;margin:20px 0"></div>
    <button class="start-btn" onclick="location.reload()">NEW GAME</button>
  </div>
</div>

<!-- Empty placeholder for offline GeoJSON data -->
<script type="application/json" id="countries110m"></script>

<!-- TopoJSON library for world map -->
<script src="https://unpkg.com/topojson-client@3"></script>

<script>
/// ============ STORAGE ============
const Storage = {
  available: false,
  
  init() {
    try {
      const test = '__test__';
      localStorage.setItem(test, test);
      localStorage.removeItem(test);
      this.available = true;
    } catch(e) {
      this.available = false;
    }
  },
  
  getItem(key) {
    if (!this.available) return null;
    try {
      return localStorage.getItem(key);
    } catch(e) {
      return null;
    }
  },
  
  setItem(key, value) {
    if (!this.available) return;
    try {
      localStorage.setItem(key, value);
    } catch(e) {}
  },
  
  removeItem(key) {
    if (!this.available) return;
    try {
      localStorage.removeItem(key);
    } catch(e) {}
  }
};
Storage.init();

// Apply persisted UI scale if available.  We store a floating point multiplier
// (e.g. 1.0 for 100%) under the key 'uiScale'.  When the page loads, read
// this value and apply a CSS transform so the interface scales within the
// viewport.  Using transform instead of the deprecated `zoom` property
// preserves layout flow and allows us to adjust the width/height to keep
// everything visible.  We also expose the scale on window for the options
// slider.
{
  const savedScale = parseFloat(Storage.getItem('uiScale') || '1');
  if (!isNaN(savedScale)) {
    // helper to apply scaling and clamp within reasonable bounds
    const applyScale = (scale) => {
      // Limit scale to between 0.5 and 1.5 to avoid runaway values
      const s = Math.max(0.5, Math.min(1.5, scale));
      document.body.style.transform = 'scale(' + s + ')';
      document.body.style.transformOrigin = '0 0';
      // Adjust the body's width/height so the scaled content fits back into the viewport
      document.body.style.width = (100 / s) + '%';
      document.body.style.height = (100 / s) + '%';
      window.uiScale = s;
    };
    applyScale(savedScale);
  }
}

// Allow options slider to update the UI scale dynamically.  This function is
// referenced from the range input `oninput` attribute.  It clamps the
// provided percentage, applies the scale via CSS transform and stores the
// value to persistent storage.  Because CSS transforms are relative to the
// top-left origin, we set transformOrigin accordingly and adjust the body
// width/height to counteract the scaling.  Without this the scaled UI would
// overflow beyond the window when the scale exceeds 100%.
function updateUIScaleSlider(value) {
  const pct = parseFloat(value);
  if (isNaN(pct)) return;
  const scale = pct / 100;
  // Clamp scale to the supported range
  const clamped = Math.max(0.5, Math.min(1.5, scale));
  document.body.style.transform = 'scale(' + clamped + ')';
  document.body.style.transformOrigin = '0 0';
  document.body.style.width = (100 / clamped) + '%';
  document.body.style.height = (100 / clamped) + '%';
  window.uiScale = clamped;
  Storage.setItem('uiScale', clamped);
  const disp = document.getElementById('uiScaleDisplay');
  if (disp) disp.textContent = Math.round(pct) + '%';
}

/// ============ PLAYER MANAGER ============
const PlayerManager = {
  _cached: null,
  
  get() {
    if (this._cached && nations.includes(this._cached)) {
      return this._cached;
    }
    
    let player = nations.find(n => n && n.isPlayer);
    if (!player && nations.length > 0) {
      player = nations[0];
      player.isPlayer = true;
    }
    
    if (player) {
      this._cached = player;
      return player;
    }
    
    return null;
  },
  
  reset() {
    this._cached = null;
  }
};

/// ============ THEMES ============
const themes = {
  synthwave: 'synthwave',
  retro80s: 'retro80s', 
  wargames: 'wargames',
  highcontrast: 'highcontrast',
  nightmode: 'nightmode'
};
let currentTheme = Storage.getItem('theme') || 'synthwave';

// ================= FONTS =================
// Available font choices.  The values are CSS font stacks assigned
// directly to the --font-main CSS variable via applyFont().  Add more
// entries here to offer additional typographic styles.
const fontChoices = {
  retro: `'Courier New', monospace`,       // classic terminal look
  sans: `'Arial', sans-serif`,            // clean sans‑serif for readability
  modern: `'Montserrat', 'Segoe UI', sans-serif` // modern rounded sans
};

/**
 * Apply the selected font by updating the --font-main CSS variable on
 * the documentElement.  Persist the choice to localStorage under
 * 'fontChoice'.
 *
 * @param {string} key The fontChoices key to apply.
 */
function applyFont(key) {
  const font = fontChoices[key] || fontChoices.retro;
  document.documentElement.style.setProperty('--font-main', font);
  Storage.setItem('fontChoice', key);
}

// Apply the saved font choice on load.  Default to 'retro' if none saved.
{
  const savedFont = Storage.getItem('fontChoice') || 'retro';
  applyFont(savedFont);
}

function applyTheme(theme) {
  document.body.className = theme;
  currentTheme = theme;
  Storage.setItem('theme', theme);
  
  if(theme === 'wargames' || theme === 'retro80s') {
    document.body.classList.add('retro-crt');
    // Disable smoothing for pixelated look on retro themes.
    if (typeof ctx !== 'undefined') ctx.imageSmoothingEnabled = false;
    if (typeof bgCtx !== 'undefined') bgCtx.imageSmoothingEnabled = false;
    if (typeof startCtx !== 'undefined') startCtx.imageSmoothingEnabled = false;
  } else {
    document.body.classList.remove('retro-crt');
    // Re‑enable smoothing on non‑retro themes for smooth vector rendering.
    if (typeof ctx !== 'undefined') ctx.imageSmoothingEnabled = true;
    if (typeof bgCtx !== 'undefined') bgCtx.imageSmoothingEnabled = true;
    if (typeof startCtx !== 'undefined') startCtx.imageSmoothingEnabled = true;
  }
  
  drawSynthGrid();
}

/// ============ AUDIO SYSTEM ============
const AudioSys = {
  musicEnabled: JSON.parse(Storage.getItem('noradMusic') ?? 'true'),
  sfxEnabled: JSON.parse(Storage.getItem('noradSFX') ?? 'true'),
  musicVolume: parseFloat(Storage.getItem('noradMusicVolume') ?? '0.3'),
  audioContext: null,
  bgMusic: null,
  bgGainNode: null,
  init() { 
    try { 
      this.audioContext = new (window.AudioContext || window.webkitAudioContext)(); 
      this.loadBackgroundMusic(); 
      // Web browsers restrict audio playback until the user interacts with the page.
      // Register a one‑time click handler to resume the AudioContext when the
      // player clicks anywhere.  Without this, background music may fail to
      // start on some browsers.  Once resumed the handler removes itself.
      const resumeCtx = () => {
        try {
          if (this.audioContext && this.audioContext.state === 'suspended') {
            this.audioContext.resume();
          }
        } catch(e) {}
        document.removeEventListener('click', resumeCtx);
      };
      document.addEventListener('click', resumeCtx);
    } catch(e) { 
      console.warn('Audio not supported'); 
    } 
  },
  async loadBackgroundMusic() {
    if (!this.audioContext) return;
    // Build a list of candidate music files.  Try to load a theme‑specific
    // soundtrack first (e.g. synthwave.mp3 for the synthwave theme or
    // bitmusic.mp3 for retro and wargames), then fall back to generic
    // filenames.  If none of these exist the loader will attempt to find
    // an MP3 matching the HTML filename as before.
    // Build an ordered list of candidate music files.  Try loading from the
    // audio/ directory first (recommended for custom soundtracks) then fall
    // back to files in the root.  Theme‑specific selections are inserted at
    // the beginning of the list.
    let musicFiles = [];
    try {
      if (typeof currentTheme !== 'undefined') {
        if (currentTheme === 'synthwave') {
          musicFiles.push('audio/synthwave.mp3');
          musicFiles.push('synthwave.mp3');
        } else if (currentTheme === 'retro80s' || currentTheme === 'wargames') {
          musicFiles.push('audio/bitmusic.mp3');
          musicFiles.push('bitmusic.mp3');
        } else if (currentTheme === 'nightmode') {
          musicFiles.push('audio/ambient.mp3');
          musicFiles.push('ambient.mp3');
        }
      }
    } catch (_) {}
    musicFiles = musicFiles.concat([
      // Add deeper subfolder variants for organised music assets
      'audio/music/norad.mp3','audio/music/synthwave.mp3','audio/music/bitmusic.mp3','audio/music/background.mp3','audio/music/music.mp3','audio/music/soundtrack.mp3',
      // Legacy locations remain for backward compatibility
      'audio/norad.mp3','audio/background.mp3','audio/music.mp3','audio/soundtrack.mp3',
      'norad.mp3','background.mp3','music.mp3','soundtrack.mp3'
    ]);
    for (const filename of musicFiles) {
      try {
        const response = await fetch(filename);
        if (response.ok) {
          const arrayBuffer = await response.arrayBuffer();
          const audioBuffer = await this.audioContext.decodeAudioData(arrayBuffer);
          this.bgMusic = this.audioContext.createBufferSource();
          this.bgGainNode = this.audioContext.createGain();
          this.bgMusic.buffer = audioBuffer;
          this.bgMusic.loop = true;
          this.bgMusic.connect(this.bgGainNode);
          this.bgGainNode.connect(this.audioContext.destination);
          this.updateMusicVolume();
          if (this.musicEnabled) { this.bgMusic.start(0); }
          console.log(`Background music loaded: ${filename}`);
          return;
        }
      } catch(e) { 
        console.log(`Could not load ${filename}:`, e.message);
      }
    }
    // If no default music file is found, attempt to load an MP3 matching the current HTML filename.
    try {
      const currentFile = location.pathname.split('/').pop() || '';
      const base = currentFile.replace(/\.html.*$/i, '');
      if (base) {
        const customName = `${base}.mp3`;
        const res = await fetch(customName);
        if (res.ok) {
          const arrayBuffer = await res.arrayBuffer();
          const audioBuffer = await this.audioContext.decodeAudioData(arrayBuffer);
          this.bgMusic = this.audioContext.createBufferSource();
          this.bgGainNode = this.audioContext.createGain();
          this.bgMusic.buffer = audioBuffer;
          this.bgMusic.loop = true;
          this.bgMusic.connect(this.bgGainNode);
          this.bgGainNode.connect(this.audioContext.destination);
          this.updateMusicVolume();
          if (this.musicEnabled) {
            this.bgMusic.start(0);
          }
          console.log(`Custom background music loaded: ${customName}`);
          return;
        }
      }
    } catch (e) {
      console.log('No matching MP3 found for current file:', e.message);
    }
    console.log('No background music file found. Place norad.mp3, background.mp3, music.mp3, soundtrack.mp3, or an MP3 matching the HTML filename in the same folder.');
    // Do not generate a fallback tone.  If no music is available, remain
    // silent rather than play an annoying tone.  This prevents an
    // irritating buzz when the user has not supplied a soundtrack.  The
    // bgMusic and bgGainNode remain null so that updateMusicVolume() has
    // no effect.  Users may add an MP3 file to enable music playback.
  },
  updateMusicVolume() { 
    if (this.bgGainNode) 
      this.bgGainNode.gain.setValueAtTime(this.musicEnabled ? this.musicVolume : 0, this.audioContext.currentTime); 
  },
  setMusicVolume(volume) { 
    this.musicVolume = Math.max(0, Math.min(1, volume)); 
    Storage.setItem('noradMusicVolume', this.musicVolume); 
    this.updateMusicVolume(); 
  },
  playSFX(type) {
    if (!this.sfxEnabled || !this.audioContext) return;
    try {
      const o = this.audioContext.createOscillator(), g = this.audioContext.createGain();
      o.connect(g); g.connect(this.audioContext.destination);
      switch(type){
        case 'launch': 
          o.frequency.setValueAtTime(800,this.audioContext.currentTime); 
          o.frequency.exponentialRampToValueAtTime(200,this.audioContext.currentTime+0.5); 
          g.gain.setValueAtTime(0.3,this.audioContext.currentTime); 
          g.gain.exponentialRampToValueAtTime(0.01,this.audioContext.currentTime+0.5); 
          break;
        case 'explosion': 
          o.type='square'; 
          o.frequency.setValueAtTime(60,this.audioContext.currentTime); 
          g.gain.setValueAtTime(0.5,this.audioContext.currentTime); 
          g.gain.exponentialRampToValueAtTime(0.01,this.audioContext.currentTime+0.8); 
          break;
        case 'beep': 
          o.frequency.setValueAtTime(1200,this.audioContext.currentTime); 
          g.gain.setValueAtTime(0.2,this.audioContext.currentTime); 
          g.gain.exponentialRampToValueAtTime(0.01,this.audioContext.currentTime+0.1); 
          break;
        case 'alert': 
          o.frequency.setValueAtTime(440,this.audioContext.currentTime); 
          o.frequency.setValueAtTime(880,this.audioContext.currentTime+0.1); 
          o.frequency.setValueAtTime(440,this.audioContext.currentTime+0.2); 
          g.gain.setValueAtTime(0.3,this.audioContext.currentTime); 
          g.gain.exponentialRampToValueAtTime(0.01,this.audioContext.currentTime+0.3); 
          break;
        case 'sonar':
          o.frequency.setValueAtTime(2000,this.audioContext.currentTime);
          o.frequency.exponentialRampToValueAtTime(500,this.audioContext.currentTime+1);
          g.gain.setValueAtTime(0.4,this.audioContext.currentTime);
          g.gain.exponentialRampToValueAtTime(0.01,this.audioContext.currentTime+1);
          break;
        case 'immigration':
          // A soft rising tone to indicate the flow of people (immigration)
          o.type = 'triangle';
          o.frequency.setValueAtTime(300, this.audioContext.currentTime);
          o.frequency.linearRampToValueAtTime(600, this.audioContext.currentTime + 0.4);
          g.gain.setValueAtTime(0.2, this.audioContext.currentTime);
          g.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.4);
          break;

        // Additional sound effects to bring more sonic variety to the game.  Each
        // case defines a short melodic pattern using oscillators.  We choose
        // different waveforms and frequency sweeps to evoke the mood of each
        // action.  These effects are intentionally brief to avoid disrupting
        // gameplay.
        case 'research':
          // Ascending twinkle to represent a breakthrough.  Starts low and
          // rises quickly, then fades.
          o.type = 'triangle';
          o.frequency.setValueAtTime(400, this.audioContext.currentTime);
          o.frequency.exponentialRampToValueAtTime(1200, this.audioContext.currentTime + 0.5);
          g.gain.setValueAtTime(0.3, this.audioContext.currentTime);
          g.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.5);
          break;
        case 'intel':
          // A sonar-like ping descending in pitch.  Suggests scanning the
          // horizon for information.
          o.type = 'sine';
          o.frequency.setValueAtTime(1500, this.audioContext.currentTime);
          o.frequency.exponentialRampToValueAtTime(300, this.audioContext.currentTime + 0.6);
          g.gain.setValueAtTime(0.25, this.audioContext.currentTime);
          g.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.6);
          break;
        case 'culture':
          // A rapid sequence of beeps representing cultural chatter.  Uses
          // square waves to stand out.
          o.type = 'square';
          o.frequency.setValueAtTime(600, this.audioContext.currentTime);
          o.frequency.setValueAtTime(900, this.audioContext.currentTime + 0.1);
          o.frequency.setValueAtTime(750, this.audioContext.currentTime + 0.2);
          g.gain.setValueAtTime(0.25, this.audioContext.currentTime);
          g.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.3);
          break;

        // A new sound signalling that construction has completed.  Uses a
        // square wave with a pleasing upward sweep to convey progress.
        case 'build':
          o.type = 'square';
          o.frequency.setValueAtTime(400, this.audioContext.currentTime);
          o.frequency.linearRampToValueAtTime(800, this.audioContext.currentTime + 0.4);
          g.gain.setValueAtTime(0.3, this.audioContext.currentTime);
          g.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.4);
          break;

        // A distinct chime used when a research project is completed.  A
        // twinkling triangle wave climbs quickly then fades, emphasising
        // intellectual discovery.
        case 'researchComplete':
          o.type = 'triangle';
          o.frequency.setValueAtTime(500, this.audioContext.currentTime);
          o.frequency.exponentialRampToValueAtTime(1500, this.audioContext.currentTime + 0.5);
          g.gain.setValueAtTime(0.35, this.audioContext.currentTime);
          g.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.5);
          break;

        // An airy harmonic used when diplomatic agreements are forged.  A
        // multi‑tone sweep evokes handshakes and accord.
        case 'diplomacy':
          o.type = 'triangle';
          o.frequency.setValueAtTime(450, this.audioContext.currentTime);
          o.frequency.setValueAtTime(600, this.audioContext.currentTime + 0.1);
          o.frequency.setValueAtTime(350, this.audioContext.currentTime + 0.2);
          g.gain.setValueAtTime(0.3, this.audioContext.currentTime);
          g.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.4);
          break;

        // A foreboding low rumble for disasters and major crises.  The
        // frequency dips before rising to a mid tone, conveying shock and
        // alarm.
        case 'disaster':
          o.type = 'sine';
          o.frequency.setValueAtTime(200, this.audioContext.currentTime);
          o.frequency.setValueAtTime(100, this.audioContext.currentTime + 0.15);
          o.frequency.setValueAtTime(300, this.audioContext.currentTime + 0.4);
          g.gain.setValueAtTime(0.4, this.audioContext.currentTime);
          g.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.5);
          break;
        case 'diplomacy':
          // Two-tone handshake signifying negotiation.  Two short pulses at
          // different frequencies.
          o.type = 'triangle';
          o.frequency.setValueAtTime(500, this.audioContext.currentTime);
          o.frequency.setValueAtTime(700, this.audioContext.currentTime + 0.15);
          g.gain.setValueAtTime(0.3, this.audioContext.currentTime);
          g.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.3);
          break;
        case 'attack':
          // A tense warble leading into silence, used when initiating an attack.
          o.type = 'sawtooth';
          o.frequency.setValueAtTime(1000, this.audioContext.currentTime);
          o.frequency.exponentialRampToValueAtTime(400, this.audioContext.currentTime + 0.4);
          g.gain.setValueAtTime(0.4, this.audioContext.currentTime);
          g.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.4);
          break;

        case 'build':
          // A short downward tone to represent construction.  The sweep
          // evokes machinery powering up then winding down as a unit is completed.
          o.type = 'square';
          o.frequency.setValueAtTime(800, this.audioContext.currentTime);
          o.frequency.linearRampToValueAtTime(300, this.audioContext.currentTime + 0.4);
          g.gain.setValueAtTime(0.25, this.audioContext.currentTime);
          g.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.4);
          break;
      }
      o.start(); 
      o.stop(this.audioContext.currentTime + 1);
    } catch(e) { 
      console.warn('SFX failed'); 
    }
  },
  toggleMusic() { 
    this.musicEnabled = !this.musicEnabled; 
    Storage.setItem('noradMusic', this.musicEnabled); 
    this.updateMusicVolume(); 
  },
  toggleSFX() { 
    this.sfxEnabled = !this.sfxEnabled; 
    Storage.setItem('noradSFX', this.sfxEnabled); 
  }
};

/// ============ GAME STATE ============
const S = {
  turn: 1,
  defcon: 5,
  lastDefcon: 5,
  phase: 'PLAYER',
  actionsRemaining: 1,
  paused: false,
  gameOver: false,
  selectedLeader: null,
  playerName: null,
  selectedDoctrine: null,
  difficulty: 'normal',
  missiles: [],
  bombers: [],
  interceptors: [],
  explosions: [],
  particles: [],
  smokeTrails: [],
  radiationZones: [],
  empEffects: [],
  craters: [],
  flashes: [],
  rings: [],
  screenShake: 0,
  fx: 1,
  overlay: null
}
// Nuclear winter globals
S.nuclearWinterLevel = S.nuclearWinterLevel || 0;
S.globalRadiation = S.globalRadiation || 0;
S.refugeeCamps = S.refugeeCamps || [];

/// ============ ATMOSPHERIC EFFECTS ============
// Provide drifting clouds and twinkling stars to give the map more depth. Clouds and
// stars remain anchored to screen coordinates rather than world coordinates, so they
// pan and zoom independently of the map. Call Atmosphere.init() once on game start,
// and Atmosphere.update() + Atmosphere.draw(ctx) each frame within gameLoop().
const Atmosphere = {
  clouds: [],
  stars: [],
  initialized: false,
  init() {
    if (this.initialized) return;
    // Create semi‑transparent clouds of varying sizes
    for (let i = 0; i < 5; i++) {
      this.clouds.push({
        x: Math.random() * W,
        y: Math.random() * H * 0.6,
        speed: 0.05 + Math.random() * 0.1,
        sizeX: 200 + Math.random() * 200,
        sizeY: 80 + Math.random() * 60
      });
    }
    // Create a field of twinkling stars
    for (let i = 0; i < 40; i++) {
      this.stars.push({
        x: Math.random() * W,
        y: Math.random() * H * 0.6,
        phase: Math.random() * Math.PI * 2
      });
    }
    this.initialized = true;
  },
  update() {
    // Move clouds horizontally. When they move off screen, wrap them around.
    this.clouds.forEach(c => {
      c.x += c.speed;
      if (c.x - c.sizeX > W) {
        c.x = -c.sizeX;
      }
    });
    // Advance the phase of the stars to make them twinkle
    this.stars.forEach(s => {
      s.phase += 0.05;
    });
  },
  draw(context) {
    if (!this.initialized) return;
    context.save();
    // Draw clouds with very low opacity so they gently overlay the background
    this.clouds.forEach(c => {
      context.globalAlpha = 0.05;
      // Tint clouds based on theme: wargames uses a muted gray, retro80s uses a bright purple/pink
      const cloudColour = currentTheme === 'wargames' ? 'rgba(150,150,150,0.6)' : 'rgba(255,200,255,0.6)';
      context.fillStyle = cloudColour;
      context.beginPath();
      context.ellipse(c.x, c.y, c.sizeX, c.sizeY, 0, 0, Math.PI * 2);
      context.fill();
    });
    // No longer draw stars behind the map.  Instead, city lights flicker gently to
    // suggest the subtle glint of civilization.  Leaving this block empty
    // improves realism when combined with the flickering city lights and
    // prevents bright star artifacts.
    context.restore();
  }
};

/// ============ OCEAN EFFECT ============
// A subtle animated wave overlay drawn across the entire canvas to suggest motion in
// oceans and seas.  The waves are independent of world position and simply oscillate
// horizontally.  You can tweak amplitude and spacing for different effects.
const Ocean = {
  offset: 0,
  update() {
    this.offset += 0.3;
    if (this.offset > 10000) this.offset = 0;
  },
  draw(context) {
    context.save();
    // Increase the opacity slightly so waves are visible on darker themes
    context.globalAlpha = 0.06;
    // Colour varies by theme; wargames gets cooler tones, retro synthwave gets warmer tones.
    const oceanColour = currentTheme === 'wargames' ? 'rgba(0,80,160,0.6)' : 'rgba(40,100,220,0.6)';
    context.strokeStyle = oceanColour;
    // Make the waves larger to produce a more noticeable motion across oceans
    const amplitude = 10;
    const period = 120;
    for (let y = 0; y < H; y += 16) {
      context.beginPath();
      for (let x = 0; x <= W; x += 20) {
        const wave = Math.sin((x + this.offset) / period + y / 80) * amplitude;
        const dy = y + wave;
        if (x === 0) context.moveTo(x, dy);
        else context.lineTo(x, dy);
      }
      context.stroke();
    }
    context.restore();
  }
};
;

/// ============ CANVAS ============
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const startCanvas = document.getElementById('startCanvas');
const startCtx = startCanvas.getContext('2d');
const bgCanvas = document.getElementById('bgGrid');
const bgCtx = bgCanvas.getContext('2d');

let W, H;

// Camera is declared early so that it exists before resizeCanvas() is first
// invoked.  If cam is defined later with let, referencing it in
// resizeCanvas() or elsewhere would throw a ReferenceError due to the
// temporal dead zone.  Declaring it here ensures it is initialized prior
// to resizeCanvas() being called at page load and on resize events.

// Define the global camera object.  Without this definition, references
// to `cam` in projection and drawing functions would throw a ReferenceError
// and prevent the world from rendering.  Initial values match the
// original implementation.
let cam = { x: 0, y: 0, zoom: 1, targetZoom: 1 };

function resizeCanvas() {
  W = window.innerWidth;
  H = window.innerHeight;
  canvas.width = W;
  canvas.height = H;
  startCanvas.width = W;
  startCanvas.height = H;
  bgCanvas.width = W;
  bgCanvas.height = H;
  drawSynthGrid();

  // Adjust camera zoom based on window size to maintain readability across
  // resolutions.  The camera (cam) might not yet be defined when
  // resizeCanvas() runs the first time (the script declares cam later in
  // the file).  Guard against a ReferenceError by checking that cam
  // exists before attempting to adjust its zoom properties.
  // Scale relative to a 1280x720 baseline, clamped to reasonable bounds.
  if (typeof cam !== 'undefined') {
    const baseW = 1280;
    const baseH = 720;
    const s = Math.min(W / baseW, H / baseH);
    cam.targetZoom = Math.max(0.6, Math.min(2.0, s));
    // Immediately update current zoom so the change is applied without delay
    cam.zoom = cam.targetZoom;

    // Center the world on screen when the zoom changes.  Without updating
    // cam.x and cam.y, the map anchors at the top‑left and may be pushed
    // entirely off screen at higher zoom levels.  By offsetting the camera
    // by half of the scaled canvas dimensions we keep the map centered.
    // At zoom=1 this is zero; at zoom>1 it is negative and recenters the
    // larger map into view.
    cam.x = (W - W * cam.zoom) / 2;
    cam.y = (H - H * cam.zoom) / 2;
  }
}
resizeCanvas();
window.addEventListener('resize', resizeCanvas);

/// ============ BACKGROUND GRID ============
function drawSynthGrid(){
  const w = W, h = H;
  bgCtx.clearRect(0, 0, w, h);
  
  if(currentTheme === 'wargames') {
    bgCtx.fillStyle='#000000'; 
    bgCtx.fillRect(0, 0, w, h);
    return;
  }
  
  const grad = bgCtx.createLinearGradient(0, 0, 0, h);
  if(currentTheme === 'retro80s') {
    grad.addColorStop(0,'#001a33'); 
    grad.addColorStop(0.5,'#001122'); 
    grad.addColorStop(1,'#000811');
  } else {
    grad.addColorStop(0,'#12041f'); 
    grad.addColorStop(0.5,'#0a0920'); 
    grad.addColorStop(1,'#050a14');
  }
  bgCtx.fillStyle = grad; 
  bgCtx.fillRect(0, 0, w, h);
  
  const horizon = Math.floor(h * 0.6);
  const sunY = horizon - 80, sunR = 110;
  const sunGrad = bgCtx.createRadialGradient(w/2, sunY, 10, w/2, sunY, sunR);
  if(currentTheme === 'retro80s') {
    sunGrad.addColorStop(0,'rgba(255,0,128,.9)'); 
    sunGrad.addColorStop(1,'rgba(255,0,128,0)');
  } else {
    sunGrad.addColorStop(0,'rgba(255,136,187,.9)'); 
    sunGrad.addColorStop(1,'rgba(255,136,187,0)');
  }
  bgCtx.fillStyle = sunGrad; 
  bgCtx.beginPath(); 
  bgCtx.arc(w/2, sunY, sunR, 0, Math.PI*2); 
  bgCtx.fill();
  
  bgCtx.strokeStyle = currentTheme === 'retro80s' ? 'rgba(0,255,65,.35)' : 'rgba(255,105,180,.35)';
  bgCtx.lineWidth = 1;
  const vanX = w/2, vanY = horizon;
  
  for(let i = -15; i <= 15; i++){
    const x0 = i * 60;
    bgCtx.beginPath();
    bgCtx.moveTo(vanX, vanY);
    bgCtx.lineTo(vanX + x0 * 10, h);
    bgCtx.stroke();
  }
  for(let r = 0; r < 18; r++){
    const y = horizon + r * r * 8;
    bgCtx.beginPath();
    bgCtx.moveTo(0, y); 
    bgCtx.lineTo(w, y); 
    bgCtx.stroke();
  }
}

/// ============ CITY LIGHTS SYSTEM ============
const CityLights = {
  cities: [],
  initialized: false,

  generate() {
    this.cities = [];
    const regions = [
      {lat: 40, lon: -74, density: 150, spread: 15},
      {lat: 34, lon: -118, density: 100, spread: 12},
      {lat: 42, lon: -87, density: 80, spread: 10},
      {lat: 51, lon: 0, density: 120, spread: 12},
      {lat: 48, lon: 2, density: 100, spread: 10},
      {lat: 52, lon: 13, density: 90, spread: 10},
      {lat: 35, lon: 139, density: 200, spread: 10},
      {lat: 39, lon: 116, density: 180, spread: 15},
      {lat: 31, lon: 121, density: 160, spread: 12},
      {lat: 28, lon: 77, density: 150, spread: 12},
      {lat: 19, lon: 72, density: 130, spread: 10},
      {lat: -23, lon: -46, density: 100, spread: 10},
      {lat: 30, lon: 31, density: 80, spread: 10},
      {lat: -26, lon: 28, density: 60, spread: 8},
      {lat: -33, lon: 151, density: 70, spread: 10},
      {lat: 55, lon: 37, density: 110, spread: 12},
    ];
    
    regions.forEach(region => {
      for (let i = 0; i < region.density; i++) {
        // Randomly scatter lights around the major city coordinates. Retry until
        // the light falls on land to avoid placing them over ocean. Limit
        // attempts to avoid infinite loops if map is not loaded yet.
        let attempt = 0;
        while (attempt < 5) {
          const ang = Math.random() * Math.PI * 2;
          const dist = (Math.random() + Math.random() + Math.random()) / 3 * region.spread;
          const lat = region.lat + Math.sin(ang) * dist;
          const lon = region.lon + Math.cos(ang) * dist;
          if (isOnLand(lat, lon)) {
            this.cities.push({
              lat, lon,
              brightness: 0.3 + Math.random() * 0.7,
              size: 0.5 + Math.random() * 1.5,
              pulse: Math.random() * Math.PI * 2,
              alive: true,
              fadeRate: 0
            });
            break;
          }
          attempt++;
        }
      }
    });
    
    // Generate additional random lights across the world but only on land.  Increase
    // the number of random points and expand the latitude range slightly to fill
    // more continental interiors.  Keep a higher attempt limit to find valid spots.
    let count = 0;
    let attempts = 0;
    const extraLights = 800;
    const maxAttempts = 4000;
    while (count < extraLights && attempts < maxAttempts) {
      const lat = (Math.random() - 0.5) * 150; // allow up to ±75 degrees
      const lon = (Math.random() - 0.5) * 360;
      attempts++;
      // Skip extreme latitudes to avoid polar regions where map projection fails
      if (Math.abs(lat) > 75) continue;
      if (!isOnLand(lat, lon)) continue;
      this.cities.push({
        lat, lon,
        brightness: 0.2 + Math.random() * 0.4,
        size: 0.3 + Math.random() * 0.7,
        pulse: Math.random() * Math.PI * 2,
        alive: true,
        fadeRate: 0
      });
      count++;
    }

    // Sprinkle additional lights around each nation's capital to fill sparse areas.
    if (typeof nations !== 'undefined') {
      nations.forEach(nation => {
        if (!nation || !nation.lat || !nation.lon) return;
        for (let i = 0; i < 20; i++) {
          const ang = Math.random() * Math.PI * 2;
          const dist = Math.random() * 5 + 2;
          const lat = nation.lat + Math.sin(ang) * dist;
          const lon = nation.lon + Math.cos(ang) * dist;
          if (!isOnLand(lat, lon)) continue;
          this.cities.push({
            lat, lon,
            brightness: 0.3 + Math.random() * 0.4,
            size: 0.3 + Math.random() * 0.7,
            pulse: Math.random() * Math.PI * 2,
            alive: true,
            fadeRate: 0
          });
        }
      });
    }
    
    this.initialized = true;
  },

  destroyNear(worldX, worldY, blastRadius) {
    let destroyed = 0;
    const R = blastRadius * 1.2;
    
    this.cities.forEach(city => {
      if (!city.alive) return;
      const [cx, cy] = project(city.lon, city.lat);
      const d = Math.hypot(cx - worldX, cy - worldY);
      
      if (d < R) {
        city.brightness = Math.min(city.brightness + 0.4, 1.5);
        city.pulse += 2.0;
        
          if (d < R * 0.6) {
          city.alive = false;
          destroyed++;
          // store geographic coordinates for afterglow so the ring follows the map
          S.rings.push({lon: city.lon, lat: city.lat, r: 1, max: 18, speed: 4, alpha: 1, type: 'afterglow'});
        } else {
          city.fadeRate = Math.max(city.fadeRate, 0.10 * (1 - d/R) + 0.02);
          if (Math.random() < 0.08 * (1 - d/R)) {
            city.alive = false;
            destroyed++;
          }
        }
      }
    });

    // Remove any immigration icons in the blast area.  Persistent icons
    // representing refugee camps will disappear if nuked.
    if (Array.isArray(S.immigrationIcons)) {
      S.immigrationIcons = S.immigrationIcons.filter(icon => {
        const [ix, iy] = project(icon.lon, icon.lat);
        const dist = Math.hypot(ix - worldX, iy - worldY);
        return dist >= R;
      });
    }
    
    return destroyed;
  },

  update() {
    this.cities.forEach(city => {
      if (!city.alive) return;

      // Gradually dim or extinguish lights based on the health of nearby nations.
      // We scale a "destruction radius" by how much population a nation has
      // lost relative to its starting value.  At full health the radius is very
      // small, while at zero population the radius grows large enough to cover
      // the entire territory.  Lights inside the radius accumulate fade rate
      // and may eventually go dark completely.  This creates the effect of
      // power failures propagating through a country as it is bombarded.
      let removedDueToNation = false;
      for (const n of nations) {
        if (!n) continue;
        const initPop = n.initialPopulation || n.population || 1;
        const ratio = (n.population || 0) / initPop;
        // Determine the dimming radius: ranges from a small value when the nation is
        // healthy to a large value when it is nearly wiped out.  When population
        // reaches zero the radius becomes very large to catch all remaining
        // lights in that territory.
        let radius;
        if (n.population <= 0) {
          radius = 100; // very large radius ensures all lights associated with this
                       // nation are removed when it collapses.  The radius
                       // exceeds the width of most continents but does not cover
                       // the entire globe, so other nations' lights remain.
        } else {
          // As ratio decreases, radius increases.  Base radius 3 degrees plus up to
          // 20 additional degrees.
          radius = 3 + (1 - ratio) * 20;
        }
        // Compute approximate distance in degrees using equirectangular approximation.
        const dLat = city.lat - n.lat;
        const dLon = (city.lon - n.lon) * Math.cos(city.lat * Math.PI / 180);
        const dist = Math.sqrt(dLat * dLat + dLon * dLon);
        if (dist < radius) {
          // If the nation is completely destroyed, immediately kill the light
          if (n.population <= 0) {
            city.alive = false;
            removedDueToNation = true;
            break;
          }
          // Otherwise increase fadeRate proportional to how badly the nation is
          // damaged.  Lights dim faster as the population ratio drops.
          const additionalFade = 0.005 + (1 - ratio) * 0.05;
          city.fadeRate = Math.max(city.fadeRate, additionalFade);
        }
      }
      if (removedDueToNation) return;

      // If the light has a fade rate, reduce brightness each frame.  Once
      // brightness falls to zero the light is considered dead.
      if (city.fadeRate > 0) {
        city.brightness -= city.fadeRate;
        if (city.brightness <= 0) {
          city.alive = false;
        }
      }
    });
  },

  draw(ctx) {
    if (!this.initialized) return;
    
    ctx.save();
    ctx.globalCompositeOperation = 'screen';
    
    const now = Date.now();
    const phase = now / 2000;
    
    this.cities.forEach(city => {
      if (!city.alive || city.brightness <= 0) return;
      
      const [x, y] = project(city.lon, city.lat);
      if (x < -50 || x > W + 50 || y < -50 || y > H + 50) return;
      
      // Increase the pulse amplitude to give city lights a gentle flicker.
      const pulse = Math.sin(phase + city.pulse) * 0.2 + 0.8;
      const b = city.brightness * pulse;
      const r = city.size * cam.zoom;
      
      ctx.fillStyle = `rgba(255,220,150,${b * 0.8})`;
      ctx.beginPath();
      ctx.arc(x, y, r, 0, Math.PI * 2);
      ctx.fill();
      
      if (city.size > 1) {
        ctx.fillStyle = `rgba(255,255,220,${b})`;
        ctx.beginPath();
        ctx.arc(x, y, r * 0.4, 0, Math.PI * 2);
        ctx.fill();
      }

      // Draw a subtle halo around the light to give a more natural falloff.  The halo
      // scales with city size and zoom and fades towards the edges.
      ctx.save();
      const haloRadius = r * 3;
      const haloGrad = ctx.createRadialGradient(x, y, 0, x, y, haloRadius);
      haloGrad.addColorStop(0, `rgba(255,220,150,${b * 0.2})`);
      haloGrad.addColorStop(1, 'rgba(255,220,150,0)');
      ctx.fillStyle = haloGrad;
      ctx.beginPath();
      ctx.arc(x, y, haloRadius, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
    });
    
    ctx.restore();
  },
  
  // FIX 4: Dynamic city methods
  addCity(lat, lon, size = 1.2) {
    if(!this.initialized) return;
    this.cities.push({
      lat, lon, 
      brightness: 0.6 + Math.random()*0.4, 
      size, 
      pulse: Math.random()*Math.PI*2, 
      alive: true, 
      fadeRate: 0
    });
  },

  getStats(){
    const total = this.cities.length || 1;
    const alive = this.cities.filter(c => c.alive).length;
    return { total, alive, percentage: Math.round(alive/total * 100) };
  }
  ,

  // Rebuild destroyed cities near given coordinates. Returns number of cities restored.
  rebuildNear(lon, lat) {
    let rebuilt = 0;
    const rebuildRadius = 100;
    this.cities.forEach(city => {
      if (city.alive) return;
      const [cx, cy] = project(city.lon, city.lat);
      const [px, py] = project(lon, lat);
      const dist = Math.hypot(cx - px, cy - py);
      if (dist < rebuildRadius) {
        city.alive = true;
        city.brightness = 0.5;
        city.fadeRate = 0;
        rebuilt++;
      }
    });
    return rebuilt;
  }
};

/// ============ CAMERA ============
// cam is declared earlier near the canvas definitions to avoid temporal
// dead zone issues when resizeCanvas() runs.  The duplicate declaration
// here has been removed.
let worldData = null;
let worldCountries = null;

/// ============ NATIONS ============
let nations = [];

/// ============ ENHANCED LEADERS LIST ============
const leaders = [
  {name: "Ronnie Raygun", ai: "aggressive", color: "#ff5555"},
  {name: "Tricky Dick", ai: "defensive", color: "#5599ff"},
  {name: "Jimi Farmer", ai: "balanced", color: "#55ff99"},
  {name: "E. Musk Rat", ai: "chaotic", color: "#ff55ff"},
  {name: "Donnie Trumpf", ai: "aggressive", color: "#ffaa55"},
  {name: "Atom Hus-Bomb", ai: "aggressive", color: "#ff3333"},
  {name: "Krazy Re-Entry", ai: "chaotic", color: "#cc44ff"},
  {name: "Odd'n Wild Card", ai: "trickster", color: "#44ffcc"},
  {name: "Oil-Stain Lint-Off", ai: "balanced", color: "#88ff88"},
  {name: "Ruin Annihilator", ai: "aggressive", color: "#ff6600"}
];

/// ============ DOCTRINES ============
const doctrines = {
  firstStrike: {
    name: "First Strike",
    desc: "Overwhelming offensive power",
    effects: "Missiles +3, Defense -20%, Aggression +30%",
    missileBonus: 3,
    defenseMultiplier: 0.8
  },
  fortress: {
    name: "Fortress", 
    desc: "Impenetrable defense",
    effects: "Defense +50%, Intercept +30%, Missiles -2",
    defenseMultiplier: 1.5,
    missileBonus: -2
  },
  diplomat: {
    name: "Diplomat",
    desc: "Peace through negotiation", 
    effects: "Trade costs -25%, Truce +1 turn, Culture +20%"
  },
  shadow: {
    name: "Shadow State",
    desc: "Intelligence supremacy",
    effects: "Intel ops +50%, Counter-intel +10"
  },
  technocrat: {
    name: "Technocracy",
    desc: "Science above all",
    effects: "Research cheaper, +2 uranium/turn"
  },
  rogue: {
    name: "Rogue State",
    desc: "No rules, no allies",
    effects: "All weapons +20% damage, Everyone hates you"
  }
};

/// ============ DIFFICULTY ============
const difficultySettings = {
  easy: {
    resourceMultiplier: 1.5,
    aiAggression: 0.7,
    startingResources: {production: 150, uranium: 15, intel: 30}
  },
  normal: {
    resourceMultiplier: 1.0,
    aiAggression: 1.0,
    startingResources: {production: 100, uranium: 10, intel: 20}
  },
  hard: {
    resourceMultiplier: 0.7,
    aiAggression: 1.3,
    startingResources: {production: 70, uranium: 7, intel: 15}
  }
};

/// ============ COSTS ============
const COSTS = {
  missile: { production: 8, uranium: 0, intel: 0 },
  bomber: { production: 20, uranium: 0, intel: 0 },
  defense: { production: 15, uranium: 0, intel: 0 },
  city: { production: 35, uranium: 0, intel: 0 },
  // Warheads now also consume production in addition to uranium to better
  // reflect the industrial effort required to build delivery systems.  These
  // values are tuned so that higher yields scale both production and uranium
  // costs proportionally.  Without a production cost players could stockpile
  // warheads too easily.
  warhead_10: { production: 5, uranium: 5, intel: 0 },
  warhead_20: { production: 8, uranium: 6, intel: 0 },
  warhead_50: { production: 12, uranium: 20, intel: 0 },
  warhead_100: { production: 20, uranium: 40, intel: 0 },
  satellite: { production: 0, uranium: 0, intel: 5 },
  sabotage: { production: 0, uranium: 0, intel: 10 },
  propaganda: { production: 0, uranium: 0, intel: 15 },
  immigration_skilled: { production: 10, uranium: 0, intel: 5 },
  immigration_mass: { production: 5, uranium: 0, intel: 2 },
  immigration_refugee: { production: 0, uranium: 0, intel: 15 },
  immigration_brain: { production: 0, uranium: 0, intel: 20 },
  // Cost to build one submarine.  Each submarine allows a single instant strike.
  submarine: { production: 40, uranium: 10, intel: 10 },
  submarine_launch: { production: 20, uranium: 0, intel: 5 }
};

// Research costs shared by player and AI so both factions follow the same
// technology pricing and prerequisites.
const TECH_COSTS = {
  better_missiles: 10,
  radar: 10,
  miniaturization: 10,
  mirv: 20,
  stealth: 20,
  emp: 20,
  submarines: 30,
  laser: 30,
  mt100: 30
};

function canAfford(nation, cost) {
  return (nation.production || 0) >= (cost.production || 0) &&
         (nation.uranium || 0) >= (cost.uranium || 0) &&
         (nation.intel || 0) >= (cost.intel || 0);
}

function pay(nation, cost) {
  nation.production = (nation.production || 0) - (cost.production || 0);
  nation.uranium = (nation.uranium || 0) - (cost.uranium || 0);
  nation.intel = (nation.intel || 0) - (cost.intel || 0);
}

function getCityCost(nation) {
  const cities = nation.cities || 1;
  return {
    production: Math.floor(35 * Math.pow(1.3, cities - 1)),
    uranium: 0,
    intel: 0
  };
}

/// ============ DEFCON ENFORCEMENT ============
function canPerformAction(action) {
  const d = S.defcon;
  
  switch(action) {
    case 'build':
    case 'diplomacy':
      return true;
      
    case 'defense':
    case 'intel':
      return d <= 4;
      
    case 'conventional':
    case 'culture':
    case 'immigration':
      return d <= 3;
      
    case 'tactical':
      return d <= 2;
      
    case 'strategic':
    case 'attack':
      return d <= 1;
      
    default:
      return false;
  }
}

/// ============ DOOMSDAY CLOCK ============
const DoomsdayClock = {
  minutes: 7,
  
  tick(amount = 0.5) {
    this.minutes = Math.max(0.5, this.minutes - amount);
    this.update();
    
    if(this.minutes <= 1) {
      nations.forEach(n => {
        if(!n.isPlayer) n.aggressionMod = (n.aggressionMod || 0) + 0.5;
      });
      log("⚠ DOOMSDAY IMMINENT!", "alert");
    }
    
    if(this.minutes <= 0) {
      this.midnight();
    }
  },
  
  improve(amount = 0.5) {
    this.minutes = Math.min(11, this.minutes + amount);
    this.update();
  },
  
  update() {
    const display = document.getElementById('doomsdayTime');
    if(display) {
      const mins = Math.floor(this.minutes);
      const secs = Math.floor((this.minutes - mins) * 60);
      display.textContent = `${mins}:${secs.toString().padStart(2, '0')}`;
    }
  },
  
  midnight() {
    log("☢☢☢ MIDNIGHT! GLOBAL THERMONUCLEAR WAR ☢☢☢", "alert");
    S.gameOver = true;
    setTimeout(() => endGame(false, "MUTUAL ASSURED DESTRUCTION"), 5000);
  }
};

/// ============ ENHANCED BANTER SYSTEM ============
const aiBanterLines = {
  balanced: [
    "Calculating acceptable losses.",
    "Deterrence only works if you believe.",
    "Escalation is a staircase—I'm on it.",
    "Your resolve seems... negotiable.",
    "Let's keep this symmetrical.",
    "Parity achieved. Next: leverage.",
    "Trade shots or trade terms?",
    "Parity now, leverage later."
  ],
  aggressive: [
    "Peace was never an option.",
    "Fire clarifies everything.",
    "Every city is a bargaining chip.",
    "I aim for overkill.",
    "Blink and you burn.",
    "I prefer outcomes, not warnings.",
    "Mercy is bankrupt.",
    "I count in craters."
  ],
  defensive: [
    "Walls hold—until they don't.",
    "Defense buys time; time buys victory.",
    "You can't outlast my patience.",
    "Attrition favors me.",
    "I can wait longer than you.",
    "Fortify. Endure. Outlast.",
    "Intercept first, ask later.",
    "Your reach exceeds your shelter."
  ],
  trickster: [
    "I prefer influence to impact.",
    "Not all wars are fought in daylight.",
    "What you don't see hurts most.",
    "Enjoy the decoys.",
    "I win by misdirection.",
    "Pressure without footprints.",
    "Your panic is my payload.",
    "Silence is the loudest weapon."
  ],
  chaotic: [
    "Chaos is a ladder, and I'm climbing.",
    "Why be predictable?",
    "Random acts of deterrence.",
    "I play dice with the universe.",
    "Entropy is my doctrine.",
    "Coin tosses build empires.",
    "Entropy favors the bold."
  ],
  reactive_hit: [
    "Noted. Retaliation uploaded.",
    "You drew first blood. I'll take the rest.",
    "Escalation accepted.",
    "I am rewriting your skyline.",
    "We trade ash for leverage.",
    "Cities fall; resolve rises.",
    "Bills are due."
  ],
  launch: [
    "Postcard from afar: boom.",
    "We prefer express delivery.",
    "History will not forgive. We will not ask.",
    "Metal birds, heavy intent.",
    "Coordinates verified. Sympathy denied.",
    "Trajectory locked; so is your fate."
  ],
  build: [
    "We plant cities where hope still listens.",
    "Industry hums, even in the dark.",
    "We choose to exist—louder.",
    "Steel today, leverage tomorrow.",
    "Factories don't sleep; rivals should."
  ],
  immigration: [
    "Your borders are... porous.",
    "Enjoy the new arrivals.",
    "Demographics are weapons too.",
    "I'm sharing my problems.",
    "Demographics decide decades.",
    "Brains travel faster than bombs."
  ],
  city_lost: [
    "You took our lights. We'll take your dawn.",
    "Cities fall. Vengeance rises.",
    "Every dark window is a promise.",
    "Skyline edited. Author noted.",
    "We rebuild. You regret."
  ],
  default: [
    "Prepared to escalate.",
    "Just warming up...",
    "Deterrence? Cute.",
    "You'll blink first.",
    "Check your radar again.",
    "The board is set. Your move.",
    "Thresholds are suggestions."
  ]
};

// Expose banter lines on the global object so that external packs (e.g. norad-banter-pack-XL.js)
// can merge their phrases into the same object.  Without this assignment the external
// script would create a separate aiBanterLines object on window, leaving the game to
// reference only its internal definitions.  By assigning our local object to
// window.aiBanterLines the two references point to the same structure and any
// additions made by external packs become immediately visible to maybeBanter().
window.aiBanterLines = aiBanterLines;

// Optionally load additional banter from an external JSON file.  This allows
// larger dialogue pools to live outside of the main HTML file so that
// the core code stays manageable.  To use, place a file named
// `banter_extra.json` in the same directory containing an object with
// the same keys as aiBanterLines (e.g. {"balanced":[...],"aggressive":[...]}).
async function loadExtraBanter() {
  try {
    const res = await fetch('banter_extra.json');
    if (res.ok) {
      const extra = await res.json();
      Object.keys(extra).forEach(key => {
        const lines = extra[key];
        if (Array.isArray(lines)) {
          if (aiBanterLines[key]) aiBanterLines[key].push(...lines);
          else aiBanterLines[key] = lines.slice();
        }
      });
      console.log('Extra banter loaded');
    }
  } catch(e) {
    console.log('No extra banter found (optional)');
  }
}
// Kick off the extra banter loading asynchronously.  The call is not awaited
// because banter lines are only needed once the AI begins speaking later in
// the game.
loadExtraBanter();

function maybeBanter(nation, chance = 0.5, poolKey = null) {
  if (!nation || Math.random() > chance) return;
  const pool = poolKey ? aiBanterLines[poolKey] : (aiBanterLines[nation.ai] || aiBanterLines.default);
  const line = pool[Math.floor(Math.random() * pool.length)];
  log(`🗨️ ${nation.name}: ${line}`, 'banter');
  // Colorize last banter entry with nation's color
  try {
    const logEl = document.getElementById('log');
    if (logEl) {
      const entries = logEl.querySelectorAll('.log-entry.banter');
      const last = entries[entries.length - 1];
      if (last && nation.color) {
        last.style.color = nation.color;
        last.style.borderLeft = '3px solid ' + nation.color;
        last.style.paddingLeft = '6px';
      }
    }
  } catch (_) {}
}

/// ============ EXPANDED RANDOM EVENTS SYSTEM ============
const RandomEvents = {
  events: [
    {id: 'solar_storm', name: 'Solar Storm', desc: "Solar storm knocks out defence systems across all nations (-2 defence each)", effect: () => {
      nations.forEach(n => n.defense = Math.max(0, n.defense - 2));
      log('☀️ SOLAR STORM! All defense systems -2', 'warning');
    }},
    {id: 'pandemic', name: 'Pandemic', desc: "A global pandemic randomly reduces population in several nations", effect: () => {
      nations.forEach(n => {
        if(Math.random() < 0.5) {
          n.population = Math.max(0, n.population - 1);
        }
      });
      log('🦠 PANDEMIC! Random nations lose population', 'warning');
    }},
    {id: 'arms_race', name: 'Arms Race', desc: "All nations accelerate their weapons programs: +1 missile each", effect: () => {
      nations.forEach(n => n.missiles++);
      DoomsdayClock.tick(0.3);
      log('🚀 ARMS RACE! All nations +1 missile', 'alert');
    }},
    {id: 'peace_protest', name: 'Peace Protests', desc: "Public protests for peace cause DEFCON to improve", effect: () => {
      if(S.defcon < 5) S.defcon++;
      log('☮️ PEACE PROTESTS! DEFCON improved', 'success');
    }},
    {id: 'nuclear_accident', name: 'Nuclear Accident', desc: "A nuclear accident reduces a random nation's warhead stockpile", effect: () => {
      const victim = nations[Math.floor(Math.random() * nations.length)];
      const types = Object.keys(victim.warheads || {});
      if(types.length > 0) {
        const type = types[0];
        victim.warheads[type]--;
        if(victim.warheads[type] <= 0) delete victim.warheads[type];
        log(`☢️ NUCLEAR ACCIDENT in ${victim.name}! Lost warhead`, 'alert');
      }
    }},
    {id: 'coup', name: 'Military Coup', desc: "A sudden coup alters the AI personality of a random nation", effect: () => {
      const victim = nations.filter(n => !n.isPlayer)[Math.floor(Math.random() * nations.filter(n => !n.isPlayer).length)];
      if(victim) {
        victim.ai = ['aggressive', 'defensive', 'chaotic'][Math.floor(Math.random() * 3)];
        log(`🎖️ COUP in ${victim.name}! New AI personality`, 'warning');
      }
    }},
    {id: 'cyber_attack', name: 'Cyber Attack', desc: "A cyber attack cripples a random nation's missile arsenal (-3 missiles)", effect: () => {
      const victim = nations[Math.floor(Math.random() * nations.length)];
      victim.missiles = Math.max(0, victim.missiles - 3);
      log(`💻 CYBER ATTACK on ${victim.name}! -3 missiles`, 'warning');
    }},
    {id: 'un_sanctions', name: 'UN Sanctions', desc: "The United Nations imposes sanctions, lowering all nations' intel by 1", effect: () => {
      nations.forEach(n => n.intel = Math.max(0, (n.intel || 0) - 1));
      log('🌍 UN SANCTIONS! All nations -1 intel', 'warning');
    }},
    {id: 'resource_boom', name: 'Resource Boom', desc: "A lucky nation discovers a resource bonanza (+10 uranium)", effect: () => {
      const lucky = nations[Math.floor(Math.random() * nations.length)];
      lucky.uranium = (lucky.uranium || 0) + 10;
      log(`💎 RESOURCE BOOM in ${lucky.name}! +10 uranium`, 'success');
    }},
    {id: 'black_market', name: 'Black Market', desc: "Widespread black market trading increases missiles for all nations (+1)", effect: () => {
      nations.forEach(n => n.missiles++);
      log('💰 BLACK MARKET TRADE! All nations +1 missile', 'warning');
    }},
    
    // Additional expanded events
    {id: 'border_crisis', name: 'Border Crisis', desc: "A border crisis triggers mass migration and instability increases", effect: () => {
      const source = nations[Math.floor(Math.random() * nations.length)];
      const target = nations.filter(n => n !== source)[Math.floor(Math.random() * (nations.length - 1))];
      const migrants = Math.floor(source.population * 0.2);
      source.population -= migrants;
      target.population += migrants;
      // Record incoming migrants so intel reports can reveal migrant levels
      target.immigrants = (target.immigrants || 0) + migrants;
      target.instability = (target.instability || 0) + 50;
      log(`🚪 BORDER CRISIS! ${migrants}M flee ${source.name} → ${target.name} (+50 instab)`, 'warning');
    }},
    {id: 'brain_drain_leak', name: 'Brain Drain', desc: "A rival nation steals one of your researched technologies", effect: () => {
      const player = PlayerManager.get();
      if(player && player.researched) {
        const techs = Object.keys(player.researched);
        if(techs.length > 0) {
          const stolen = techs[Math.floor(Math.random() * techs.length)];
          const rival = nations.filter(n => !n.isPlayer)[Math.floor(Math.random() * nations.filter(n => !n.isPlayer).length)];
          if(rival) {
            rival.researched = rival.researched || {};
            rival.researched[stolen] = true;
            log(`🧠 BRAIN DRAIN! ${rival.name} steals your ${stolen} technology`, 'alert');
          }
        }
      }
    }},
    {id: 'factory_fire', name: 'Factory Fire', desc: "An industrial accident destroys a city and applies a production debuff", effect: () => {
      const player = PlayerManager.get();
      if(player) {
        if(player.cities > 1) player.cities--;
        player.productionDebuff = (player.productionDebuff || 0) + 0.1;
        log('🔥 FACTORY FIRE! -1 city, -10% production next turn', 'alert');
      }
    }},
    {id: 'satellite_collision', name: 'Satellite Collision', desc: "Debris collision destroys all of your satellites", effect: () => {
      const player = PlayerManager.get();
      if(player) {
        player.satellites = {};
        log('💥 SATELLITE COLLISION! Lost all surveillance coverage', 'warning');
      }
    }},
    {id: 'defcon_miscommunication', name: 'DEFCON Miscommunication', desc: "An erroneous alert changes the DEFCON level randomly", effect: () => {
      const change = Math.random() < 0.5 ? 1 : -1;
      S.defcon = Math.max(1, Math.min(5, S.defcon + change));
      log(`📡 DEFCON MISCOMMUNICATION! Alert level ${change > 0 ? 'lowered' : 'raised'} to ${S.defcon}`, change > 0 ? 'success' : 'warning');
    }},
    {id: 'peace_rally', name: 'Peace Rally', desc: "A peace rally reduces your instability and improves DEFCON", effect: () => {
      const player = PlayerManager.get();
      if(player) {
        player.instability = Math.max(0, (player.instability || 0) - 10);
        if(S.defcon < 5) S.defcon++;
        log('✌️ PEACE RALLY! Your instability -10, DEFCON improved', 'success');
      }
    }},
    {id: 'unexpected_truce', name: 'Unexpected Truce', desc: "Two AI nations unexpectedly agree to a cease-fire for two turns", effect: () => {
      const ai1 = nations.filter(n => !n.isPlayer)[0];
      const ai2 = nations.filter(n => !n.isPlayer)[1];
      if(ai1 && ai2) {
        ai1.treaties = ai1.treaties || {};
        ai2.treaties = ai2.treaties || {};
        ai1.treaties[ai2.id] = {truceTurns: 2};
        ai2.treaties[ai1.id] = {truceTurns: 2};
        log(`🤝 UNEXPECTED TRUCE! ${ai1.name} and ${ai2.name} agree to 2-turn cease-fire`, 'success');
      }
    }} ,

    // Newly added global resource crises.  These events are meant to
    // reduce runaway resource accumulation and make the late game more
    // unpredictable.  When triggered they apply a modest penalty to
    // production or uranium across all nations.
    {id: 'energy_crisis', name: 'Energy Crisis', desc: 'A worldwide energy shortage reduces production for all nations', effect: () => {
      nations.forEach(n => {
        // Subtract a flat amount of production to simulate factories
        // running at reduced capacity.  Use Math.max to avoid negative
        // production.  Notify the log once per event.
        n.production = Math.max(0, (n.production || 0) - 5);
      });
      log('⚡ ENERGY CRISIS! All nations -5 production', 'warning');
    }},
    {id: 'uranium_shortage', name: 'Uranium Shortage', desc: 'Global uranium supplies dwindle; all nations lose uranium', effect: () => {
      nations.forEach(n => {
        // Remove three units of uranium from each nation.  Ensure the
        // value does not dip below zero.  This curbs stockpiling and
        // encourages strategic use of nuclear resources.
        n.uranium = Math.max(0, (n.uranium || 0) - 3);
      });
      log('🔋 URANIUM SHORTAGE! All nations -3 uranium', 'warning');
    }},
    // New urgent global events.  These disasters trigger a timed prompt
    // that requires immediate player action.  Respond quickly to
    // mitigate the impact, or suffer harsher penalties.  Each effect
    // calls showUrgentEvent() with appropriate callbacks and audio.
    {id: 'earthquake', name: 'Earthquake', desc: "A massive earthquake threatens your cities; respond promptly to reduce casualties", effect: () => {
      AudioSys.playSFX('alert');
      const player = PlayerManager.get();
      if (!player) return;
      showUrgentEvent('EARTHQUAKE', 'A massive earthquake strikes your cities! Respond within 8s to send aid and reduce casualties.', () => {
        const loss = Math.max(1, Math.floor(player.population * 0.02));
        player.population = Math.max(0, player.population - loss);
        player.production = Math.max(0, (player.production || 0) - 5);
        log(`🌐 Earthquake: ${loss}M casualties and -5 production`, 'warning');
        updateDisplay();
      }, () => {
        const loss = Math.max(3, Math.floor(player.population * 0.05));
        player.population = Math.max(0, player.population - loss);
        log(`💀 Earthquake: ${loss}M casualties due to slow response`, 'alert');
        updateDisplay();
      }, 8000);
    }},
    {id: 'hurricane', name: 'Hurricane', desc: "A devastating hurricane strikes; quick action can mitigate losses", effect: () => {
      AudioSys.playSFX('alert');
      const player = PlayerManager.get();
      if (!player) return;
      showUrgentEvent('HURRICANE', 'A devastating hurricane hits coastal cities! Respond within 10s to mobilize evacuations.', () => {
        const loss = Math.max(1, Math.floor(player.population * 0.015));
        player.population = Math.max(0, player.population - loss);
        player.uranium = Math.max(0, (player.uranium || 0) - 3);
        log(`🌀 Hurricane: ${loss}M casualties and -3 uranium`, 'warning');
        updateDisplay();
      }, () => {
        const loss = Math.max(4, Math.floor(player.population * 0.04));
        player.population = Math.max(0, player.population - loss);
        log(`🌀 Hurricane ravaged your coasts: ${loss}M casualties`, 'alert');
        updateDisplay();
      }, 10000);
    }},
    {id: 'uprising', name: 'Uprising', desc: "An uprising threatens your regime; your response will determine its impact", effect: () => {
      AudioSys.playSFX('alert');
      const player = PlayerManager.get();
      if (!player) return;
      showUrgentEvent('UPRISING', 'Internal unrest threatens your regime! Respond within 7s with security forces or risk instability.', () => {
        player.instability = Math.max(0, (player.instability || 0) - 10);
        player.intel = Math.max(0, (player.intel || 0) - 5);
        log('⚖️ Uprising quelled: -5 intel, instability reduced', 'warning');
        updateDisplay();
      }, () => {
        player.instability = (player.instability || 0) + 20;
        log('🔥 Uprising spreads! Instability +20', 'alert');
        updateDisplay();
      }, 7000);
    }},
  ],
  
  trigger() {
    if(Math.random() < 0.25 && S.turn > 3) {
      const event = this.events[Math.floor(Math.random() * this.events.length)];
      event.effect();
      // After applying the event effect, show an informational card with the event description.
      try {
        showEventCard(event.id, event.name, event.desc);
      } catch(_) {}
      return true;
    }
    return false;
  }
};

/// ============ INIT NATIONS ============
function initNations() {
  const diff = difficultySettings[S.difficulty];
  
  nations = [{
    id: 'player',
    isPlayer: true,
    name: 'PLAYER',
    leader: S.selectedLeader,
    doctrine: S.selectedDoctrine,
    lon: -95,
    lat: 40,
    color: '#00ffff',
    population: 100,
    // Store the original population so we can scale down city lights as the
    // nation takes damage.  This value remains constant throughout the game
    // and is used to compute population ratios in CityLights.update().
    initialPopulation: 100,
    missiles: 8 + (doctrines[S.selectedDoctrine]?.missileBonus || 0),
    bombers: 2,
    defense: 5,
    instability: 0,
    warheads: {10: 5, 20: 3, 50: 1},
    production: diff.startingResources.production,
    uranium: diff.startingResources.uranium,
    intel: diff.startingResources.intel,
    cities: 1,
    researched: {},
    treaties: {},
    submarines: 0,
    // Cover operations hide your arsenal from enemy satellites for a
    // limited time.  Deep reconnaissance timers are stored in a
    // dictionary keyed by target id.  They are initialised here
    // to ensure safe property access even before any intel actions
    // occur.
    coverOpsTurns: 0,
    deepRecon: {},
    // Track incoming migrants.  This counts the total number of
    // immigrants that have relocated to the nation via crisis events or
    // immigration actions.  Displayed in intel reports when spying.
    immigrants: 0,
    // Track perceived threats from other nations.  The AI uses this
    // dictionary to decide who to retaliate against.  Keys are
    // nation IDs, values are cumulative damage received.
    threats: {}
    ,migrantsThisTurn: 0
    ,migrantsTotal: 0
  }];
  
  const aiPositions = [
    {lon: 37, lat: 55, name: 'EURASIA'},
    {lon: 116, lat: 40, name: 'EASTASIA'},
    {lon: -60, lat: -15, name: 'SOUTHAM'},
    {lon: 20, lat: 0, name: 'AFRICA'}
  ];
  
  // Randomize the selection of AI leaders.  Exclude the player's chosen
  // leader from the pool, shuffle the remaining leaders, and assign the
  // first few to the AI positions.  This ensures variety in opponents each
  // playthrough.
  const availableLeaders = leaders.filter(l => l.name !== S.selectedLeader);
  const shuffled = availableLeaders.slice().sort(() => Math.random() - 0.5);
  for (let i = 0; i < Math.min(4, shuffled.length); i++) {
    const leader = shuffled[i];
    const doctrineKeys = Object.keys(doctrines);
    const aiDoctrine = doctrineKeys[Math.floor(Math.random() * doctrineKeys.length)];
    const pos = aiPositions[i];
    nations.push({
      id: `ai_${i}`,
      isPlayer: false,
      name: pos.name,
      leader: leader.name,
      ai: leader.ai,
      doctrine: aiDoctrine,
      lon: pos.lon,
      lat: pos.lat,
      color: leader.color,
      population: 60 + Math.random() * 40,
      initialPopulation: null,
      missiles: 5 + Math.floor(Math.random() * 5),
      bombers: Math.floor(Math.random() * 3),
      defense: 3 + Math.floor(Math.random() * 5),
      instability: Math.random() * 20,
      warheads: {10: 3, 20: 2},
      production: 50 + Math.floor(Math.random() * 50),
      uranium: 5 + Math.floor(Math.random() * 10),
      intel: 10 + Math.floor(Math.random() * 20),
      cities: 1,
      researched: {},
      treaties: {},
        submarines: 0,
        // Number of immigrants currently residing in this nation.  Increased
        // whenever immigration events occur.  Used only for intel display.
        immigrants: 0,
        // Each AI nation keeps track of who has attacked it and the cumulative
        // destructive yield received.  This threat dictionary is used later
        // when deciding retaliation targets.  Keys are attacker IDs and
        // values are accumulated megatonnage.
        threats: {}
      ,migrantsThisTurn: 0
      ,migrantsTotal: 0
    });
  }

  // After all nations are created, ensure every nation has an initialPopulation
  // recorded.  For the player this was set explicitly above; for AI nations
  // we copy the current population value.  Without this step the AI
  // nations' initialPopulation would remain null and city light dimming
  // logic would not function correctly.
  nations.forEach(n => {
    if (n.initialPopulation == null) {
      n.initialPopulation = n.population;
    }
  });
  
  PlayerManager.reset();
}

/// ============ FIX 1: PRODUCTION PHASE ============
function productionPhase() {
  // Adjust resource generation based on difficulty and rebalanced base values.
  // Previous values granted very large gains per city (15/4/2).  To better balance the pacing
  // of the game, we scale the base gains down (8/2/1 for production, uranium and intel respectively)
  // and reduce the population contribution.  These values are further multiplied by the
  // difficulty-specific resourceMultiplier so that easy yields > normal > hard.  This ensures
  // growth pressure remains meaningful at higher difficulties and rewards early expansion on easy.
  const mult = difficultySettings[S.difficulty]?.resourceMultiplier ?? 1;
  nations.forEach(n => {
    if (!n || n.population <= 0) return;
    const cities = n.cities || 1;
    const pop = n.population || 0;
    // Rebalanced base gains: city contribution is lower and population factors scaled down
    // Further reduce production output.  Previous rebalance still produced
    // too much resource accumulation, so scale down both city and
    // population contributions.  Uranium and intel remain as before.
    // New base resource generation values for better pacing on all difficulties.
    // Production: cities*4 + pop*0.15, Uranium: cities*1 + pop*0.03, Intel: cities*0.5 + pop*0.05.
    const baseProd = cities * 4 + pop * 0.15;
    const baseUran = cities * 1 + pop * 0.03;
    const baseIntel = cities * 0.5 + pop * 0.05;
    let prodGain = Math.floor(baseProd * mult);
    let uranGain = Math.floor(baseUran * mult) + (n.doctrine === 'technocrat' ? 2 : 0);
    let intelGain = Math.floor(baseIntel * mult);
    // Apply any ongoing production debuffs from events or culture ops.  Each point
    // of debuff is a multiplicative reduction (e.g. 0.15 = -15%).
    if (n.productionDebuff) {
      prodGain = Math.floor(prodGain * (1 - n.productionDebuff));
    }
    // Apply temporary green shift debuffs from environmental propaganda.
    if (n.greenShiftTurns && n.greenShiftTurns > 0) {
      prodGain = Math.floor(prodGain * 0.6);
      uranGain = Math.floor(uranGain * 0.5);
      n.greenShiftTurns--;
    }

    // Apply environmental treaty penalties from diplomacy.  This
    // debuff is milder than eco propaganda but still reduces both
    // production and uranium income each turn.  It decays over
    // time and is stored on the affected nation.
    if (n.environmentPenaltyTurns && n.environmentPenaltyTurns > 0) {
      prodGain = Math.floor(prodGain * 0.7);
      uranGain = Math.floor(uranGain * 0.7);
      n.environmentPenaltyTurns--;
    }
    // Maintenance costs: owning missiles and defence systems consumes part of your production each turn.
    // Each missile costs 0.5 production and each defence level costs 0.3 production per turn.
    const missileMaintenance = (n.missiles || 0) * 0.5;
    const defenceMaintenance = (n.defense || 0) * 0.3;
    const maintenance = Math.ceil(missileMaintenance + defenceMaintenance);
    prodGain = Math.max(0, prodGain - maintenance);
    n.production = (n.production || 0) + prodGain;
    n.uranium = (n.uranium || 0) + uranGain;
    n.intel = (n.intel || 0) + intelGain;
    if (n.isPlayer) {
      log(`📊 Production: +${prodGain} PROD | +${uranGain} URAN | +${intelGain} INTEL (Total: ${n.production}/${n.uranium}/${n.intel})`, 'success');
    }
  });
}

/// ============ RESOLUTION PHASE ============
function resolutionPhase() {
  RandomEvents.trigger();
  // Reset migrant counters each turn.  At the start of the resolution
  // phase we record how many migrants arrived in the previous turn and
  // then clear the per-turn counter so that new immigrants are counted
  // separately next round.  This enables the intel view to display
  // migrant flow this turn and total migrants.
  nations.forEach(n => {
    n.migrantsLastTurn = n.migrantsThisTurn || 0;
    n.migrantsThisTurn = 0;
  });

  // Countdown and expire trade sanctions
  nations.forEach(n => {
    if (n.sanctionTurns > 0) {
      n.sanctionTurns--;
      if (n.sanctionTurns === 0) {
        n.sanctioned = false;
        log(`Sanctions on ${n.name} expired`);
      }
    }
  });
  
  nations.forEach(n => {
    if(n.treaties) {
      Object.keys(n.treaties).forEach(targetId => {
        if(n.treaties[targetId].truceTurns > 0) {
          n.treaties[targetId].truceTurns--;
          if(n.treaties[targetId].truceTurns <= 0) {
            log(`Truce expired between ${n.name} and ${nations.find(t => t.id === targetId)?.name}`);
          }
        }
      });
    }
  });
  
  nations.forEach(n => {
    if (!n || n.population <= 0) return;
    
    const instab = n.instability || 0;
    
    if (instab >= 50) {
      const revoltChance = Math.min(0.35, instab / 100 * 0.3);
      
      if (Math.random() < revoltChance) {
        const popLoss = 3 + Math.floor(Math.random() * 8);
        const defLoss = 1;
        const missileLoss = Math.floor(Math.random() * 3);
        
        n.population = Math.max(0, n.population - popLoss);
        n.defense = Math.max(0, n.defense - defLoss);
        n.missiles = Math.max(0, n.missiles - missileLoss);
        n.instability = Math.max(0, instab - 15);
        
        log(`💥 REVOLT in ${n.name}! -${popLoss}M pop, -${defLoss} def`, 'alert');
        
        if (n.isPlayer) {
          S.screenShake = 10;
          AudioSys.playSFX('alert');
        }
      }
    }
    
    if (instab >= 100) {
      n.population = Math.floor(n.population * 0.5);
      n.instability = 50;
      log(`💀 CIVIL WAR in ${n.name}!`, 'alert');
    }
    
    n.instability = Math.max(0, instab - 3);
  });
  
  S.radiationZones.forEach(zone => {
    zone.intensity *= 0.95;
    
    nations.forEach(n => {
      const [x, y] = project(n.lon, n.lat);
      const dist = Math.hypot(x - zone.x, y - zone.y);
      if (dist < zone.radius) {
        const damage = zone.intensity * 3;
        n.population = Math.max(0, n.population - damage);
      }
    });
  });
  
  CityLights.update();
  
  log('=== RESOLUTION PHASE COMPLETE ===', 'success');

  // At the end of each turn, decrement any temporary intelligence
  // effects.  Deep reconnaissance and cover operations expire after a
  // fixed number of turns.  Remove entries that reach zero.
  const player = PlayerManager.get();
  if (player) {
    // Reduce coverOpsTurns used to hide the player's arsenal.  When
    // the timer reaches zero the player's information is again
    // available to opponents with satellites.
    if (player.coverOpsTurns && player.coverOpsTurns > 0) {
      player.coverOpsTurns--;
    }
    // Update deep recon timers for each target.  If the timer
    // expires for a given nation, delete the entry so it no longer
    // grants enhanced information.  Use Object.keys to iterate
    // because deepRecon may be undefined until first use.
    if (player.deepRecon) {
      Object.keys(player.deepRecon).forEach(id => {
        if (player.deepRecon[id] > 0) {
          player.deepRecon[id]--;
        }
        if (player.deepRecon[id] <= 0) {
          delete player.deepRecon[id];
        }
      });
    }
  }


  // Nuclear winter step effects
  if(S.nuclearWinterLevel && S.nuclearWinterLevel > 0){
    const winterSeverity = Math.min(S.nuclearWinterLevel / 10, 0.5);
    nations.forEach(n => {
      // Increase population loss during nuclear winter to accelerate decline at high severity.
      const popLoss = Math.floor((n.population || 0) * winterSeverity * 0.10);
      if(popLoss>0) n.population = Math.max(0, (n.population||0) - popLoss);
      if(typeof n.production === 'number'){
        n.production = Math.max(0, Math.floor(n.production * (1 - winterSeverity)));
      }
    });
    if(S.nuclearWinterLevel > 5){
      log(`☢️ NUCLEAR WINTER! Global population declining!`, 'alert');
      S.overlay = {text: 'NUCLEAR WINTER', ttl: 2000};
    }
    S.nuclearWinterLevel *= 0.95; // decay slowly
  }

  // Apply a soft population cap to prevent runaway growth.  If a
  // nation's population exceeds 1200M (1.2B), reduce the excess by
  // 25% each turn.  This keeps numbers within plausible bounds and
  // keeps the scoreboard readable.  Also round all populations down
  // to whole numbers to maintain granularity in millions.
  nations.forEach(n => {
    if (n.population > 1200) {
      const excess = n.population - 1200;
      const reduction = Math.floor(excess * 0.25);
      n.population = Math.max(1200, n.population - reduction);
    }
    n.population = Math.floor(n.population || 0);
  });
}

/// ============ WORLD MAP ============
async function loadWorld() {
  const CACHE_NAME = 'offlineTopo110m';
  
  try {
    const cached = Storage.getItem(CACHE_NAME);
    if(cached) {
      const data = JSON.parse(cached);
      if (data.type === 'Topology' && window.topojson) {
        worldData = data;
        worldCountries = topojson.feature(data, data.objects.countries || data.objects.land);
        log('World map loaded from cache');
        gameLoop();
        return;
      } else if (data.type === 'FeatureCollection') {
        worldCountries = data;
        log('World map loaded from cache (GeoJSON)');
        gameLoop();
        return;
      }
    }
  } catch(e) {
    console.warn('Cache load failed:', e);
  }

  try {
    const inlineEl = document.getElementById('countries110m');
    if(inlineEl && inlineEl.textContent.trim().length > 10) {
      const data = JSON.parse(inlineEl.textContent);
      if(data.type === 'FeatureCollection') {
        worldCountries = data;
        log('World map loaded from inline GeoJSON');
        gameLoop();
        return;
      }
    }
  } catch(e) {
    console.warn('Inline GeoJSON parse failed:', e);
  }

  try {
    log('Fetching world map from CDN...');
    const response = await fetch('https://unpkg.com/world-atlas@2/countries-110m.json');
    if(response.ok) {
      const topo = await response.json();
      
      try {
        Storage.setItem(CACHE_NAME, JSON.stringify(topo));
      } catch(e) {
        console.warn('Could not cache map data');
      }
      
      if(window.topojson && topo.objects) {
        worldData = topo;
        worldCountries = topojson.feature(topo, topo.objects.countries || topo.objects.land);
        log('World map loaded from CDN');
        gameLoop();
        return;
      }
    }
  } catch(e) {
    console.warn('CDN fetch failed:', e);
  }

  worldCountries = {
    type: "FeatureCollection",
    features: [
      {
        type: "Feature",
        properties: {name: "Americas"},
        geometry: {
          type: "Polygon",
          coordinates: [[
            [-170,70],[-100,71],[-80,50],[-75,25],[-80,10],[-85,-10],
            [-75,-30],[-70,-55],[-75,-55],[-80,-30],[-85,-10],[-95,0],
            [-105,20],[-120,35],[-130,40],[-140,50],[-160,60],[-170,70]
          ]]
        }
      },
      {
        type: "Feature",
        properties: {name: "Eurasia"},
        geometry: {
          type: "Polygon",
          coordinates: [[
            [-10,35],[0,40],[10,45],[30,50],[50,55],[80,60],[120,65],
            [140,60],[160,55],[170,60],[180,65],[180,70],[140,75],
            [80,75],[20,70],[-10,60],[-10,35]
          ]]
        }
      },
      {
        type: "Feature",
        properties: {name: "Africa"},
        geometry: {
          type: "Polygon",
          coordinates: [[
            [-20,35],[-15,30],[-10,20],[0,5],[10,-5],[20,-15],
            [30,-30],[25,-35],[20,-34],[15,-30],[10,-20],[5,-10],
            [0,0],[-5,10],[-10,20],[-15,30],[-20,35]
          ]]
        }
      },
      {
        type: "Feature",
        properties: {name: "Australia"},
        geometry: {
          type: "Polygon",
          coordinates: [[
            [110,-10],[115,-15],[125,-20],[135,-25],[145,-30],
            [150,-35],[145,-40],[135,-38],[125,-35],[115,-30],
            [110,-20],[110,-10]
          ]]
        }
      }
    ]
  };
  
  log('Using fallback continent outlines');
  gameLoop();
}

/// ============ DRAWING ============
function project(lon, lat) {
  const x = ((lon + 180) / 360) * W * cam.zoom + cam.x;
  const y = ((90 - lat) / 180) * H * cam.zoom + cam.y;
  return [x, y];
}

// Convert from screen coordinates back to geographic coordinates.  This is the inverse
// of project() and is used for effects that must follow the map when the camera pans
// or zooms.  Given a pixel coordinate (px, py) relative to the canvas and the current
// camera state, returns [lon, lat].
function toLonLat(px, py) {
  const lon = ((px - cam.x) / (W * cam.zoom)) * 360 - 180;
  const lat = 90 - ((py - cam.y) / (H * cam.zoom)) * 180;
  return [lon, lat];
}

// ===================== LAND CHECK UTILITIES =====================
// Determine if a point lies inside a polygon using the ray casting algorithm.
// Accepts a point [lon, lat] and an array of polygon vertices [[lon,lat], ...].
function pointInPolygon(point, vs) {
  let x = point[0], y = point[1];
  let inside = false;
  for (let i = 0, j = vs.length - 1; i < vs.length; j = i++) {
    const xi = vs[i][0], yi = vs[i][1];
    const xj = vs[j][0], yj = vs[j][1];
    const intersect = ((yi > y) !== (yj > y)) &&
      (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
    if (intersect) inside = !inside;
  }
  return inside;
}

// Return true if the given latitude/longitude lies on land (inside any country
// polygon). If worldCountries is not yet loaded, fall back to allowing the
// position so lights still appear until the map loads.
function isOnLand(lat, lon) {
  if (!worldCountries || !worldCountries.features) return true;
  for (const feature of worldCountries.features) {
    const geom = feature.geometry;
    if (!geom) continue;
    if (geom.type === 'Polygon') {
      if (pointInPolygon([lon, lat], geom.coordinates[0])) return true;
    } else if (geom.type === 'MultiPolygon') {
      for (const poly of geom.coordinates) {
        if (pointInPolygon([lon, lat], poly[0])) return true;
      }
    }
  }
  return false;
}

function drawWorld() {
  if(!worldCountries) return;
  
  ctx.save();
  ctx.strokeStyle = 'rgba(0,255,255,0.3)';
  ctx.lineWidth = 1;
  
  worldCountries.features.forEach(feature => {
    ctx.beginPath();
    const coords = feature.geometry.coordinates;
    
    if(feature.geometry.type === 'Polygon') {
      drawWorldPath(coords[0]);
    } else if(feature.geometry.type === 'MultiPolygon') {
      coords.forEach(poly => drawWorldPath(poly[0]));
    }
    
    ctx.stroke();
  });
  
  ctx.restore();
  
  ctx.save();
  ctx.strokeStyle = 'rgba(0,255,255,0.1)';
  ctx.lineWidth = 0.5;
  
  for(let lon = -180; lon <= 180; lon += 30) {
    ctx.beginPath();
    for(let lat = -90; lat <= 90; lat += 5) {
      const [x, y] = project(lon, lat);
      if(lat === -90) ctx.moveTo(x, y);
      else ctx.lineTo(x, y);
    }
    ctx.stroke();
  }
  
  for(let lat = -90; lat <= 90; lat += 30) {
    ctx.beginPath();
    for(let lon = -180; lon <= 180; lon += 5) {
      const [x, y] = project(lon, lat);
      if(lon === -180) ctx.moveTo(x, y);
      else ctx.lineTo(x, y);
    }
    ctx.stroke();
  }
  
  ctx.restore();
  
  const scanY = (Date.now() / 30) % H;
  ctx.fillStyle = 'rgba(0,255,255,0.05)';
  ctx.fillRect(0, scanY, W, 2);
}

function drawWorldPath(coords) {
  coords.forEach((coord, i) => {
    const [x, y] = project(coord[0], coord[1]);
    if(i === 0) ctx.moveTo(x, y);
    else ctx.lineTo(x, y);
  });
}

function drawNations() {
  // Debug log
  if(nations.length === 0) {
    console.error('drawNations called but no nations exist!');
    return;
  }
  
  nations.forEach(n => {
    if (n.population <= 0) return;

    const [x, y] = project(n.lon, n.lat);
    
    // Debug check if coordinates are valid
    if(isNaN(x) || isNaN(y)) {
      console.error('Invalid coordinates for nation:', n.name, n.lon, n.lat);
      return;
    }

    // marker (triangle) as before
    ctx.save();
    ctx.fillStyle = n.color;
    ctx.strokeStyle = n.color;
    ctx.lineWidth = 2;
    ctx.shadowColor = n.color;
    ctx.shadowBlur = 20;

    ctx.beginPath();
    ctx.moveTo(x, y - 20);
    ctx.lineTo(x - 15, y + 12);
    ctx.lineTo(x + 15, y + 12);
    ctx.closePath();
    ctx.stroke();
    ctx.globalAlpha = 0.3;
    ctx.fill();
    ctx.globalAlpha = 1;
    ctx.restore();

    // Labels over nation: leader/player + nation name
    const displayName = n.isPlayer
      ? (S.playerName || S.selectedLeader || 'PLAYER')
      : (n.leader || n.name);
    const nationName = n.name;

    const z = Math.max(0.9, Math.min(1.6, cam.zoom));
    const pad = 4 * z;

    ctx.save();
    ctx.textAlign = 'center';

    ctx.font = `bold ${Math.round(12 * z)}px monospace`;
    const w1 = ctx.measureText(displayName).width;

    ctx.font = `${Math.round(11 * z)}px monospace`;
    const w2 = ctx.measureText(nationName).width;

    const bw = Math.max(w1, w2) + pad * 2;
    const bh = (12 * z + 12 * z) + pad * 2;
    const lx = x;
    const lyTop = (y - 36 * z) - (bh - (12 * z));

    ctx.fillStyle = 'rgba(0,0,0,0.45)';
    ctx.fillRect(lx - bw / 2, lyTop, bw, bh);

    ctx.globalAlpha = 0.4;
    ctx.strokeStyle = n.color;
    ctx.strokeRect(lx - bw / 2, lyTop, bw, bh);
    ctx.globalAlpha = 1;

    ctx.font = `bold ${Math.round(12 * z)}px monospace`;
    ctx.fillStyle = n.color;
    ctx.shadowColor = n.color;
    ctx.shadowBlur = 8;
    ctx.fillText(displayName, lx, lyTop + pad + 12 * z);
    ctx.shadowBlur = 0;

    ctx.font = `${Math.round(11 * z)}px monospace`;
    ctx.fillStyle = '#ffffff';
    ctx.fillText(nationName, lx, lyTop + pad + 12 * z + 12 * z);

    ctx.restore();

    // Population under marker (unchanged functional)
    ctx.save();
    ctx.fillStyle = '#00ff00';
    ctx.font = `${Math.round(10 * z)}px monospace`;
    ctx.textAlign = 'center';
    ctx.fillText(`${Math.floor(n.population)}M`, x, y + 30 * z);
    ctx.restore();

    // Draw extra city indicators for the player.  For every additional city beyond the first,
    // draw a small golden square near the nation marker.  This gives a quick visual cue
    // about how many cities the player has built without opening menus.  The squares scale
    // with the current zoom so they remain visible at all zoom levels.
    if (n.isPlayer && (n.cities || 1) > 1) {
      const extras = Math.min((n.cities || 1) - 1, 10); // cap to avoid overflow
      const sizeSq = 4 * z;
      const startX = x + 18 * z; // position squares to the right of the marker
      const startY = y + 26 * z; // just beneath the population text
      ctx.save();
      ctx.fillStyle = 'rgba(255, 215, 0, 0.9)';
      for (let i = 0; i < extras; i++) {
        // wrap to next row after 5 squares to avoid long chains
        const row = Math.floor(i / 5);
        const col = i % 5;
        const sqX = startX + col * (sizeSq + 2 * z);
        const sqY = startY + row * (sizeSq + 2 * z);
        ctx.fillRect(sqX, sqY, sizeSq, sizeSq);
      }
      ctx.restore();
    }
  });
}

function drawMissiles() {
  S.missiles.forEach((m, i) => {
    m.t = Math.min(1, m.t + 0.016);
    const [sx, sy] = project(m.fromLon, m.fromLat);
    const [tx, ty] = project(m.toLon, m.toLat);
    const u = 1 - m.t;
    // Adjust the curvature of the trajectory.  Base amplitude is 150px,
    // modulated by the missile's curveOffset property.  This adds
    // variability to the height of the arc, preventing every missile
    // from following the same parabola.
    const amplitude = 150 + ((m.curveOffset || 0) * 200);
    const cx = (sx + tx) / 2;
    const cy = (sy + ty) / 2 - amplitude;
    const x = u*u*sx + 2*u*m.t*cx + m.t*m.t*tx;
    const y = u*u*sy + 2*u*m.t*cy + m.t*m.t*ty;

    // Draw the ballistic trajectory and missile dot.  Dash and colour schemes
    // adapt to the current theme: synthwave uses a smooth neon beam, while
    // retro and wargames favour a pixelated dashed line without glow.
    ctx.save();
    ctx.globalCompositeOperation = 'lighter';
    if (typeof currentTheme !== 'undefined' && currentTheme === 'synthwave') {
      // Synthwave: bold neon beam with glow
      ctx.strokeStyle = m.color || 'rgba(255,0,255,0.9)';
      ctx.lineWidth = 2;
      ctx.setLineDash([]);
      ctx.shadowColor = ctx.strokeStyle;
      ctx.shadowBlur = 12;
    } else {
      // Retro / Wargames: thin dashed line, greenish hue, minimal glow
      ctx.strokeStyle = m.color || 'rgba(0,255,0,0.8)';
      ctx.lineWidth = 1;
      ctx.setLineDash([8,4]);
      ctx.shadowColor = ctx.strokeStyle;
      ctx.shadowBlur = 0;
    }
    ctx.lineDashOffset = - (Date.now()/60)%100;
    ctx.beginPath();
    ctx.moveTo(sx, sy);
    ctx.quadraticCurveTo(cx, cy, tx, ty);
    ctx.stroke();
    // Reset dash to draw missile head as a solid dot
    ctx.setLineDash([]);
    ctx.fillStyle = '#ffffff';
    ctx.beginPath();
    ctx.arc(x, y, 4, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();
    // Emit a faint smoke or spark trail behind the missile.  The trail
    // particles dissipate quickly and add visual dynamism to the launch.
    // Skip sub-munitions to avoid excessive particle counts.
    if (!m.isSubmunition && Math.random() < 0.6) {
      S.particles.push({
        x: x,
        y: y,
        vx: (Math.random() - 0.5) * 0.3,
        vy: (Math.random() - 0.5) * 0.3,
        life: 180,
        max: 180,
        type: 'smoke'
      });
    }

    // Incoming alert indicator
    if (!m._tele && m.t > 0.8) {
      m._tele = true;
      // convert screen position to geographic coordinates so the incoming alert follows the target
      const [lon, lat] = toLonLat(tx, ty);
      S.rings.push({lon: lon, lat: lat, r: 2, max: 60 * (S.fx || 1), speed: 3, alpha: 1, type: 'incoming', txt: 'INCOMING'});
    }

    // MIRV splitting: if missile is MIRV and has not split, split at 70% flight
    if (m.isMIRV && m.t > 0.7 && !m.split) {
      m.split = true;
      const spread = 20;
      const count = m.warheadCount || 1;
      for (let j = 0; j < count - 1; j++) {
        const angle = (j / Math.max(1, count - 1)) * Math.PI * 2;
        const offsetX = Math.cos(angle) * spread;
        const offsetY = Math.sin(angle) * spread;
        S.missiles.push({
          from: m.from,
          to: m.to,
          t: m.t,
          fromLon: m.fromLon,
          fromLat: m.fromLat,
          toLon: m.toLon + offsetX / 10,
          toLat: m.toLat + offsetY / 10,
          yield: m.yield,
          target: m.target,
          color: '#ffff00',
          isSubmunition: true
        });
      }
      log(`MIRV SPLIT! ${count} warheads spreading`, 'warning');
    }

    // Allied defense interception (skip submarine launches)
    if (!m.isSubmarine && m.t >= 0.95 && !m.interceptChecked) {
      m.interceptChecked = true;
      const allies = nations.filter(n => 
        n.treaties?.[m.target.id]?.alliance && 
        n.defense > 0
      );
      let totalIntercept = (m.target.defense || 0) / 16;
      allies.forEach(ally => {
        const allyIntercept = (ally.defense || 0) / 32;
        totalIntercept += allyIntercept;
        if (Math.random() < allyIntercept) {
          log(`${ally.name} helps defend ${m.target.name}!`, 'success');
        }
      });
      if (Math.random() < totalIntercept) {
        S.missiles.splice(i, 1);
        log(`Missile intercepted! Allied defense network successful`, 'success');
        // store intercept marker at geographic position so it moves with the camera
        const [ilon, ilat] = toLonLat(tx, ty);
        S.rings.push({lon: ilon, lat: ilat, r: 1, max: 40, speed: 3, alpha: 1, type: 'intercept'});
        return;
      }
    }

    // Detonate when missile reaches target
    if (m.t >= 1) {
      explode(tx, ty, m.target, m.yield);
      S.missiles.splice(i, 1);
    }
  });
}

// FIXED drawBombers with interception
function drawBombers() {
  S.bombers.forEach((bomber, i) => {
    bomber.t += 0.016 / 3;
    
    // Detection at midpoint
    if (bomber.t > 0.5 && !bomber.detected && bomber.to) {
      bomber.detected = true;
      const isStealthBomber = bomber.from?.researched?.stealth;
      log(`⚠️ ${isStealthBomber ? 'STEALTH ' : ''}BOMBER DETECTED approaching ${bomber.to.name}!`, 'warning');
      const baseIntercept = (bomber.to.defense || 0) / 12;
      const interceptChance = isStealthBomber ? baseIntercept * 0.5 : baseIntercept;
      if (Math.random() < interceptChance) {
        S.bombers.splice(i, 1);
        log(`✓ ${isStealthBomber ? 'Stealth bomber' : 'Bomber'} intercepted by ${bomber.to.name}!`, 'success');
        AudioSys.playSFX('explosion');
        return;
      } else if (isStealthBomber && Math.random() < 0.3) {
        log(`Stealth bomber evades detection!`, 'success');
      }
    }
    
    const x = bomber.sx + (bomber.tx - bomber.sx) * bomber.t;
    const y = bomber.sy + (bomber.ty - bomber.sy) * bomber.t;
    
    ctx.save();
    ctx.fillStyle = 'rgba(255,255,100,0.9)';
    ctx.strokeStyle = 'rgba(255,255,100,0.8)';
    ctx.lineWidth = 2;
    
    const dx = bomber.tx - bomber.sx;
    const dy = bomber.ty - bomber.sy;
    const angle = Math.atan2(dy, dx);
    
    ctx.translate(x, y);
    ctx.rotate(angle);
    
    ctx.beginPath();
    ctx.moveTo(8, 0);
    ctx.lineTo(-8, -4);
    ctx.lineTo(-6, 0);
    ctx.lineTo(-8, 4);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
    
    ctx.restore();
    
    if(bomber.t >= 1.0) {
      explode(bomber.tx, bomber.ty, bomber.to, bomber.payload.yield);
      S.bombers.splice(i, 1);
    }
  });
}


function launchSubmarine(from, to, yieldMT){
  const [fx, fy] = project(from.lon, from.lat);
  const [tx, ty] = project(to.lon, to.lat);
  S.submarines = S.submarines || [];
  S.submarines.push({
    x: fx + (Math.random() - 0.5) * 50,
    y: fy + (Math.random() - 0.5) * 50,
    phase: 0, // 0=surfacing,1=launching,2=diving
    targetX: tx, targetY: ty,
    yield: yieldMT, target: to, from
  });
  AudioSys.playSFX('launch');
  return true;
}

function drawSubmarines(){
  S.submarines = S.submarines || [];
  S.submarines.forEach((sub, i) => {
    ctx.save();
    if(sub.phase === 0){
      // surfacing
      sub.phaseProgress = Math.min(1, (sub.phaseProgress || 0) + 0.03);
      const p = sub.phaseProgress;
      ctx.globalCompositeOperation = 'lighter';
      ctx.fillStyle = `rgba(100,200,255,${1-p})`;
      ctx.beginPath();
      ctx.arc(sub.x, sub.y, 30 * p, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = '#333';
      ctx.fillRect(sub.x - 15, sub.y - 3 + (1-p)*10, 30, 6);
      if(p >= 1){
        sub.phase = 1;
        // launch missile immediately
        const missile = {
          from: sub.from || null,
          to: sub.target, t: 0.5,
          fromLon: 0, fromLat: 0,
          toLon: sub.target.lon, toLat: sub.target.lat,
          yield: sub.yield, target: sub.target,
          color: '#00ffff',
          isSubmarine: true
        };
        S.missiles.push(missile);
        log(`SUBMARINE LAUNCH! Missile away!`, 'alert');
      }
    } else if(sub.phase === 1){
      sub.phase = 2;
    } else if(sub.phase === 2){
      sub.diveProgress = (sub.diveProgress || 0) + 0.02;
      ctx.globalAlpha = 1 - sub.diveProgress;
      ctx.fillStyle = '#333';
      ctx.fillRect(sub.x - 15, sub.y - 3 + sub.diveProgress*10, 30, 6);
      if(sub.diveProgress >= 1){
        S.submarines.splice(i, 1);
      }
    }
    ctx.restore();
  });
}



function drawParticles() {
  S.particles = S.particles.filter(p => {
    p.x += p.vx;
    p.y += p.vy;
    p.life -= 16;
    p.vx *= 0.98;
    p.vy *= 0.98;
    
    if(p.life <= 0) return false;
    
    const a = p.life / p.max;
    
    ctx.save();
    if (p.type === 'smoke') {
      ctx.globalCompositeOperation = 'source-over';
      ctx.globalAlpha = a * 0.6;
      ctx.fillStyle = `rgba(180,180,180,${a * 0.6})`;
      ctx.beginPath();
      ctx.arc(p.x, p.y, 2.5, 0, Math.PI * 2);
      ctx.fill();
    } else if (p.type === 'spark') {
      // Sparks are bright, fast‑moving particles that radiate from the blast
      ctx.globalCompositeOperation = 'lighter';
      ctx.globalAlpha = a;
      // Randomize the orange/yellow tint slightly for variety
      const g = 150 + Math.floor(Math.random() * 80);
      ctx.fillStyle = `rgba(255,${g},50,${a * 0.9})`;
      ctx.beginPath();
      ctx.arc(p.x, p.y, 2.0, 0, Math.PI * 2);
      ctx.fill();
    } else {
      ctx.globalCompositeOperation = 'lighter';
      ctx.globalAlpha = a;
      ctx.fillStyle = `rgba(255,255,100,${a * 0.9})`;
      ctx.fillRect(p.x - 1.5, p.y - 1.5, 3, 3);
    }
    ctx.restore();
    
    return true;
  });
}


// Refugee camps visualizations
function createRefugeeCamp(fromNation, toNation, size){
  // Store geographic position of the camp instead of static screen coordinates.  This allows
  // the camp to follow the map when the user pans or zooms.  An offset is stored to scatter
  // tents around the target nation in a small area (in pixels) but applied in the projected
  // coordinate space.
  const [tx, ty] = project(toNation.lon, toNation.lat);
  const offX = (Math.random() - 0.5) * 40;
  const offY = (Math.random() - 0.5) * 40;
  S.refugeeCamps = S.refugeeCamps || [];
  S.refugeeCamps.push({
    lon: toNation.lon,
    lat: toNation.lat,
    offX: offX,
    offY: offY,
    size: Math.max(1, size | 0),
    fromColor: fromNation.color || '#ffaa00',
    duration: 100
  });
}

// ============== IMMIGRATION ICONS ==============
// Array to track temporary icons overlaying cities when immigration occurs
S.immigrationIcons = S.immigrationIcons || [];

// Push a new immigration icon at the given geographic location.  You can
// optionally specify a CSS colour and whether the icon should persist.
// Persisting icons do not fade away and are used for refugee waves so that
// camps remain visible until the associated city is destroyed.  Use color
// strings like '#00ff88' or rgba() for custom hues.
function addImmigrationIcon(lon, lat, color = null, persist = false) {
  S.immigrationIcons.push({ lon, lat, ttl: persist ? Infinity : 150, color, persist });
}

// Draw and update immigration icons. Each icon consists of a simple person-like
// symbol rendered at the projected lat/lon. Icons fade out based on ttl and
// are removed when expired.
function drawImmigrationIcons() {
  if (!S.immigrationIcons) return;
  for (let i = S.immigrationIcons.length - 1; i >= 0; i--) {
    const icon = S.immigrationIcons[i];
    // Only reduce ttl for non‑persistent icons.  Persistent icons remain until
    // explicitly removed by game logic (e.g. nuking the host city).
    if (!icon.persist) icon.ttl--;
    if (icon.ttl <= 0) {
      S.immigrationIcons.splice(i, 1);
      continue;
    }
    const [x, y] = project(icon.lon, icon.lat);
    let alpha;
    if (icon.persist) {
      // Persistent icons maintain a subtle pulsing transparency
      const t = Date.now() / 600;
      alpha = 0.6 + 0.3 * Math.sin(t);
    } else {
      alpha = Math.min(1, icon.ttl / 50);
    }
    const size = 8 * cam.zoom;
    ctx.save();
    ctx.globalAlpha = alpha;
    ctx.fillStyle = icon.color || 'rgba(255, 230, 150, 0.9)';
    // Head
    ctx.beginPath();
    ctx.arc(x, y - size * 0.3, size * 0.3, 0, Math.PI * 2);
    ctx.fill();
    // Body (triangle)
    ctx.beginPath();
    ctx.moveTo(x, y);
    ctx.lineTo(x - size * 0.4, y + size * 0.8);
    ctx.lineTo(x + size * 0.4, y + size * 0.8);
    ctx.closePath();
    ctx.fill();
    ctx.restore();
  }
}

function drawRefugeeCamps(){
  S.refugeeCamps = (S.refugeeCamps || []).filter(camp => {
    camp.duration--;
    // Recalculate projected position each frame so camps move with the camera
    const [bx, by] = project(camp.lon, camp.lat);
    const cx = bx + (camp.offX || 0);
    const cy = by + (camp.offY || 0);
    ctx.save();
    ctx.globalAlpha = camp.duration / 100;
    ctx.strokeStyle = camp.fromColor;
    ctx.lineWidth = 1;
    for (let i = 0; i < camp.size; i++) {
      const tentX = cx + (i % 5) * 8 - 16;
      const tentY = cy + Math.floor(i / 5) * 8 - 8;
      ctx.beginPath();
      ctx.moveTo(tentX - 3, tentY + 3);
      ctx.lineTo(tentX, tentY - 3);
      ctx.lineTo(tentX + 3, tentY + 3);
      ctx.closePath();
      ctx.stroke();
    }
    ctx.fillStyle = '#ffaa00';
    ctx.font = '9px monospace';
    ctx.fillText('REFUGEES', cx, cy + 20);
    ctx.restore();
    return camp.duration > 0;
  });
}

function drawFX() {
  if(S.screenShake && S.screenShake > 0) {
    const shakeX = (Math.random() - 0.5) * S.screenShake;
    const shakeY = (Math.random() - 0.5) * S.screenShake;
    ctx.save();
    ctx.translate(shakeX, shakeY);
    S.screenShake *= 0.9;
  }
  
  S.rings = S.rings || [];
  S.rings.forEach((b, i) => {
    // Update ring radius
    b.r += b.speed || 2;
    const a = (1 - b.r / b.max) * (b.alpha || 1);
    ctx.save();
    ctx.globalCompositeOperation = 'lighter';
    let col = `rgba(255,121,198,${a})`;
    if (b.type === 'shock') col = `rgba(255,170,90,${a})`;
    if (b.type === 'incoming') col = `rgba(255,255,255,${a})`;
    if (b.type === 'afterglow') col = `rgba(255,255,200,${a})`;
    if (b.type === 'sonar') col = `rgba(100,255,255,${a})`;
    if (b.type === 'flash') col = `rgba(255,255,255,${a})`;
    if (b.type === 'plasma') col = `rgba(255,70,180,${a})`;
    ctx.strokeStyle = col;
    ctx.lineWidth = 3;
    // Determine on-screen position: if the ring has geographic coordinates, project them; otherwise use static x/y
    let rx = b.x;
    let ry = b.y;
    if (b.lon !== undefined && b.lat !== undefined) {
      const projected = project(b.lon, b.lat);
      rx = projected[0];
      ry = projected[1];
    }
    ctx.beginPath();
    ctx.arc(rx, ry, b.r, 0, Math.PI * 2);
    ctx.stroke();
    if (b.txt) {
      ctx.fillStyle = `rgba(255,255,255,${a})`;
      ctx.font = 'bold 12px monospace';
      ctx.textAlign = 'center';
      ctx.fillText(b.txt, rx, ry - 12);
    }
    ctx.restore();
    if (b.r >= b.max) S.rings.splice(i, 1);
  });
  
  S.radiationZones.forEach((zone, i) => {
    if(zone.intensity < 0.01) {
      S.radiationZones.splice(i, 1);
      return;
    }
    
    ctx.save();
    const pulse = Math.sin(Date.now() / 500) * 0.2 + 0.8;
    ctx.globalCompositeOperation = 'screen';
    
    const grad = ctx.createRadialGradient(zone.x, zone.y, 0, zone.x, zone.y, zone.radius);
    grad.addColorStop(0, `rgba(150,255,0,${zone.intensity * 0.3 * pulse})`);
    grad.addColorStop(1, `rgba(255,100,0,0)`);
    
    ctx.fillStyle = grad;
    ctx.beginPath();
    ctx.arc(zone.x, zone.y, zone.radius, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();
  });
  
  S.empEffects.forEach((emp, i) => {
    // radial EMP glow
    ctx.save();
    ctx.globalCompositeOperation='screen';
    const g=ctx.createRadialGradient(emp.x, emp.y, 0, emp.x, emp.y, emp.radius);
    g.addColorStop(0, `rgba(100,200,255,${(emp.duration/30)*0.3})`);
    g.addColorStop(1, 'rgba(100,200,255,0)');
    ctx.fillStyle=g;
    ctx.beginPath();ctx.arc(emp.x,emp.y,emp.radius,0,Math.PI*2);ctx.fill();
    ctx.restore();
    emp.duration--;
    if(emp.duration <= 0) {
      S.empEffects.splice(i, 1);
      return;
    }
    
    ctx.save();
    ctx.globalCompositeOperation = 'screen';
    
    const arcs = 5;
    for(let j = 0; j < arcs; j++) {
      const angle = (Date.now() / 100 + j * Math.PI * 2 / arcs) % (Math.PI * 2);
      const x2 = emp.x + Math.cos(angle) * emp.radius;
      const y2 = emp.y + Math.sin(angle) * emp.radius;
      
      ctx.strokeStyle = `rgba(100,200,255,${emp.duration / 30})`;
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(emp.x, emp.y);
      
      const segments = 8;
      for(let k = 1; k <= segments; k++) {
        const t = k / segments;
        const mx = emp.x + (x2 - emp.x) * t + (Math.random() - 0.5) * 20;
        const my = emp.y + (y2 - emp.y) * t + (Math.random() - 0.5) * 20;
        ctx.lineTo(mx, my);
      }
      ctx.stroke();
    }
    
    ctx.restore();
  });
  
  // Overlay large text
  if(S.overlay && S.overlay.ttl>0){
    S.overlay.ttl -= 16;
    ctx.save();
    ctx.textAlign='center';
    ctx.font='bold 28px monospace';
    ctx.fillStyle='rgba(255,255,255,0.9)';
    ctx.strokeStyle='rgba(0,0,0,0.6)';
    ctx.lineWidth=4;
    ctx.strokeText(S.overlay.text, canvas.width/2, 80);
    ctx.fillText(S.overlay.text, canvas.width/2, 80);
    ctx.restore();
    if(S.overlay.ttl<=0) S.overlay=null;
  }

  if(S.screenShake) {
    ctx.restore();
  }

  // Nuclear winter overlay
  if(S.nuclearWinterLevel && S.nuclearWinterLevel > 1){
    ctx.save();
    ctx.fillStyle = `rgba(50,50,50,${Math.min(S.nuclearWinterLevel/20, 0.4)})`;
    ctx.fillRect(0, 0, W, H);
    ctx.restore();
  }
}

// Add submarine strike visual effect
function drawSubmarineStrike(target) {
  const [tx, ty] = project(target.lon, target.lat);
  // store sonar ring using geographic coordinates so it follows the map
  const [slon, slat] = toLonLat(tx, ty);
  S.rings.push({
    lon: slon, lat: slat, r: 1, max: 100, speed: 4,
    alpha: 0.8, type: 'sonar',
    txt: 'SUBMARINE STRIKE'
  });
  AudioSys.playSFX('sonar');
}

/// ============ LOGGING ============
function log(msg, type = 'normal') {
  const logEl = document.getElementById('log');
  if (!logEl) return;
  const entry = document.createElement('div');
  entry.className = `log-entry ${type}`;
  entry.textContent = `[T${S.turn}] ${msg}`;
  logEl.appendChild(entry);
  logEl.scrollTop = logEl.scrollHeight;
}

/// ============ EXPLOSIONS ============
function explode(x, y, target, yieldMT) {
  AudioSys.playSFX('explosion');
  
  const scale = Math.sqrt(yieldMT / 20);
  const particleCount = Math.floor(100 * scale);
  
  const blastRadius = Math.sqrt(yieldMT) * 10;
  const destroyed = CityLights.destroyNear(x, y, blastRadius);
  if (destroyed > 0) {
    log(`💡 ${destroyed} cities went dark`, 'warning');
  }
  if (target && !target.isPlayer) {
    maybeBanter(target, 0.7, destroyed > 0 ? 'city_lost' : 'reactive_hit');
  }
  
  for(let i = 0; i < particleCount; i++) {
    const a = Math.random() * Math.PI * 2;
    const speed = (1 + Math.random() * 3) * scale;
    S.particles.push({
      x, y,
      vx: Math.cos(a) * speed, 
      vy: Math.sin(a) * speed, 
      life: 500 + Math.random() * 500, 
      max: 1000
    });
  }
  
  // Convert explosion position to geographic coordinates so shock/heat rings follow the map
  const [elon, elat] = toLonLat(x, y);
  S.rings.push({lon: elon, lat: elat, r: 3, max: 120 * scale * (S.fx || 1), speed: 2, alpha: 1, type: 'shock'});
  S.rings.push({lon: elon, lat: elat, r: 1, max: 40 * (S.fx || 1), speed: 1.5, alpha: 0.8, type: 'heat'});

  // Add additional visual layers to the explosion: a bright flash and a plasma ring.
  S.rings.push({lon: elon, lat: elat, r: 2, max: 80 * scale * (S.fx || 1), speed: 2.5, alpha: 0.9, type: 'flash'});
  S.rings.push({lon: elon, lat: elat, r: 4, max: 100 * scale * (S.fx || 1), speed: 1.5, alpha: 0.7, type: 'plasma'});

  // Create additional spark particles that radiate outwards with a bright color.
  const sparkCount = Math.floor(50 * scale);
  for (let j = 0; j < sparkCount; j++) {
    const a2 = Math.random() * Math.PI * 2;
    const spd = (0.5 + Math.random() * 2.5) * scale;
    S.particles.push({
      x, y,
      vx: Math.cos(a2) * spd,
      vy: Math.sin(a2) * spd,
      life: 300 + Math.random() * 300,
      max: 600,
      type: 'spark'
    });
  }

  // Apply a stronger screen shake proportional to the explosion size
  S.screenShake = Math.max(S.screenShake || 0, 10 * scale);
  
  S.radiationZones.push({
    x, y,
    radius: Math.sqrt(yieldMT) * 8,
    intensity: yieldMT / 100
  });
  
  
  // Track nuclear winter accumulation
  if(yieldMT >= 50){
    S.nuclearWinterLevel += (yieldMT || 0) / 100;
    S.globalRadiation += (yieldMT || 0) / 200;
  }
if(yieldMT >= 50) {
    // mushroom smoke particles
    for(let s=0;s<20*(S.fx||1);s++){
      const ang = Math.random()*Math.PI*2;
      const rad = Math.random()*8;
      S.particles.push({x:x+Math.cos(ang)*rad, y:y+Math.sin(ang)*rad, vx:(Math.random()-0.5)*0.4, vy:-0.6 - Math.random()*0.4, life: 900+Math.random()*600, max: 1500, type:'smoke'});
    }

    S.empEffects.push({
      x, y,
      radius: Math.sqrt(yieldMT) * 15,
      duration: 30
    });
    
    nations.forEach(n => {
      const [nx, ny] = project(n.lon, n.lat);
      const dist = Math.hypot(nx - x, ny - y);
      if(dist < Math.sqrt(yieldMT) * 15) {
        n.defense = Math.max(0, n.defense - 3);
        n.missiles = Math.max(0, n.missiles - 2);
        log(`⚡ EMP disabled ${n.name}'s electronics!`, 'warning');
      }
    });

    // Enhanced EMP for researched nations
    if (target && target.researched?.emp) {
      const empRadius = Math.sqrt(yieldMT) * 20; // Larger radius
      const empPower = yieldMT / 20;
      S.empEffects.push({
        x, y,
        radius: empRadius,
        duration: 45, // Longer duration
        isPowerful: true
      });
      nations.forEach(n => {
        const [nx2, ny2] = project(n.lon, n.lat);
        const d2 = Math.hypot(nx2 - x, ny2 - y);
        if (d2 < empRadius) {
          n.defense = Math.max(0, n.defense - Math.floor(empPower));
          n.missiles = Math.max(0, n.missiles - Math.floor(empPower * 1.5));
          n.production = Math.max(0, n.production - 20);
          if (n.satellites) n.satellites = {};
          log(`⚡⚡ ENHANCED EMP! ${n.name} systems crippled!`, 'alert');
        }
      });
    }
  }
  
  if(yieldMT >= 50) {
    S.screenShake = Math.min(20, yieldMT / 10);
  }
  
  if(target) {
    const reduction = Math.max(0, 1 - target.defense * 0.05);
    const damage = yieldMT * reduction;
    target.population = Math.max(0, target.population - damage);
    target.instability = Math.min(100, (target.instability || 0) + yieldMT);
    
    log(`💥 ${yieldMT}MT detonation at ${target.name}! -${Math.floor(damage)}M`, "alert");
    
    if(yieldMT >= 50) {
      DoomsdayClock.tick(0.5);
    }
  }
  
  checkVictory();
}

/// ============ LAUNCH ============
function launch(from, to, yieldMT) {
  // Check for active truce
  if (from.treaties?.[to.id]?.truceTurns > 0) {
    log(`Cannot attack ${to.name} - truce active!`, 'warning');
    return false;
  }
  // DEFCON restrictions
  if (yieldMT > 50 && S.defcon > 1) {
    log(`Strategic weapons require DEFCON 1 (current: ${S.defcon})`, 'warning');
    return false;
  }
  if (yieldMT <= 50 && S.defcon > 2) {
    log(`Tactical nukes require DEFCON 2 or lower (current: ${S.defcon})`, 'warning');
    return false;
  }
  // Must have warheads
  if (!from.warheads || !from.warheads[yieldMT] || from.warheads[yieldMT] <= 0) {
    return false;
  }
  // Determine if MIRV is available
  const isMIRV = from.researched?.mirv && from.warheads[yieldMT] >= 3;
  const warheadCount = isMIRV ? 3 : 1;
  // Deduct warheads and missile
  from.warheads[yieldMT] -= warheadCount;
  if (from.warheads[yieldMT] <= 0) {
    delete from.warheads[yieldMT];
  }
  from.missiles--;
  // Create main missile.  To add visual variety, assign each missile a
  // random curve offset that will modulate the height of its ballistic
  // trajectory when drawn.  A negative offset produces a flatter arc,
  // while a positive offset produces a higher lob.  Store the
  // originating and target geographic coordinates alongside the offset.
  S.missiles.push({
    from,
    to,
    t: 0,
    fromLon: from.lon,
    fromLat: from.lat,
    toLon: to.lon,
    toLat: to.lat,
    yield: yieldMT,
    target: to,
    color: from.color,
    isMIRV: isMIRV,
    warheadCount: warheadCount,
    // random curvature multiplier between -0.3 and 0.3
    curveOffset: (Math.random() - 0.5) * 0.6
  });

  // Update the target's threat memory so that AI can weigh retaliation
  // decisions.  Accumulate the total megatonnage directed at this nation
  // by attacker ID.  Ensure the threats object exists on the target.
  try {
    const damage = yieldMT * warheadCount;
    if (to) {
      to.threats = to.threats || {};
      to.threats[from.id] = (to.threats[from.id] || 0) + damage;
    }
  } catch (_) {}
  // Log launch
  log(`${from.name} → ${to.name}: LAUNCH ${isMIRV ? 'MIRV ' : ''}${yieldMT}MT${isMIRV ? ' x3' : ''}`);
  AudioSys.playSFX('launch');
  DoomsdayClock.tick(isMIRV ? 0.5 : 0.3);
  return true;
}

function launchBomber(from, to, payload) {
  const [sx, sy] = project(from.lon, from.lat);
  const [tx, ty] = project(to.lon, to.lat);
  
  S.bombers.push({
    from, to,
    t: 0,
    sx, sy, tx, ty,
    payload
  });
  
  return true;
}

/// ============ UPDATE DISPLAY ============
function updateDisplay() {
  const player = PlayerManager.get();
  if (!player) {
    console.error('No player found!');
    return;
  }
  
  document.getElementById('defcon').textContent = S.defcon;
  document.getElementById('turn').textContent = S.turn;
  
  const maxActions = S.defcon >= 4 ? 1 : S.defcon >= 2 ? 2 : 3;
  document.getElementById('actionsDisplay').textContent = `${S.actionsRemaining}/${maxActions}`;
  
  document.getElementById('phaseBadge').textContent = `PHASE: ${S.phase}`;
  
  document.getElementById('productionDisplay').textContent = player.production || 0;
  document.getElementById('uraniumDisplay').textContent = player.uranium || 0;
  document.getElementById('intelDisplay').textContent = player.intel || 0;
  document.getElementById('citiesDisplay').textContent = player.cities || 1;
  document.getElementById('popDisplay').textContent = Math.floor(player.population);
  
  document.getElementById('leaderDisplay').textContent = player.leader;
  document.getElementById('doctrineDisplay').textContent = (player.doctrine || 'none').toUpperCase();
  document.getElementById('missileDisplay').textContent = player.missiles;
  document.getElementById('bomberDisplay').textContent = player.bombers || 0;
  document.getElementById('defenseDisplay').textContent = player.defense;
  document.getElementById('instabilityDisplay').textContent = Math.floor(player.instability || 0);
  
  const warheadText = Object.entries(player.warheads || {})
    .map(([y, c]) => `${y}MT:${c}`)
    .join(' ');
  document.getElementById('warheadDisplay').textContent = warheadText || 'NONE';

  // Display available submarines.  If submarines property is undefined, show 0.
  const subElem = document.getElementById('submarineDisplay');
  if (subElem) {
    subElem.textContent = player.submarines || 0;
  }

  // Update the UI accent color based on DEFCON level.  The colour gradually shifts
  // from calm blue/green at DEFCON 5 to intense red at DEFCON 1.
  updateDefconUIColor();

  if (S.defcon !== S.lastDefcon) {
    showDefconChange(S.defcon);
    S.lastDefcon = S.defcon;
  }

  // Victory countdown display (survival victory)
  const turnsToVictory = 50 - S.turn;
  const existingVC = document.getElementById('victoryCountdown');
  if (turnsToVictory > 0 && turnsToVictory <= 10) {
    const countdownDiv = document.createElement('div');
    countdownDiv.style.cssText = `
      position: absolute;
      top: 100px;
      right: 10px;
      background: rgba(0,255,0,0.1);
      border: 2px solid var(--green);
      padding: 10px;
      text-align: center;
      animation: pulse 1s infinite;
    `;
    countdownDiv.innerHTML = `
      <div style="color:var(--green);font-size:12px">SURVIVAL VICTORY IN</div>
      <div style="color:#fff;font-size:24px;font-weight:bold">${turnsToVictory}</div>
      <div style="color:var(--green);font-size:10px">TURNS</div>
    `;
    if (existingVC) existingVC.remove();
    countdownDiv.id = 'victoryCountdown';
    document.body.appendChild(countdownDiv);
  } else if (existingVC) {
    existingVC.remove();
  }

  // Culture dominance progress display
  const totalIntel = nations.reduce((sum, n) => sum + (n.intel || 0), 0);
  const existingCP = document.getElementById('cultureProgress');
  if (player && totalIntel > 0 && player.intel / totalIntel > 0.4) {
    const cultPercent = Math.floor((player.intel / totalIntel) * 100);
    const cultDiv = document.createElement('div');
    cultDiv.style.cssText = `
      position: absolute;
      top: 200px;
      right: 10px;
      background: rgba(255,0,255,0.1);
      border: 2px solid var(--mag);
      padding: 10px;
    `;
    cultDiv.innerHTML = `
      <div style="color:var(--mag);font-size:12px">CULTURE DOMINANCE</div>
      <div style="color:#fff;font-size:18px">${cultPercent}%</div>
      <div style="color:var(--mag);font-size:10px">Need 50% for victory</div>
    `;
    if (existingCP) existingCP.remove();
    cultDiv.id = 'cultureProgress';
    document.body.appendChild(cultDiv);
  } else if (existingCP) {
    existingCP.remove();
  }
  
  // Add technology count display
  const techCount = Object.keys(player.researched || {}).length;
  const existingTech = document.getElementById('techCountDisplay');
  if (!existingTech && techCount > 0) {
    const techEl = document.createElement('div');
    techEl.id = 'techCountDisplay';
    techEl.className = 'status-row';
    techEl.innerHTML = `<span>TECHNOLOGIES:</span><span>${techCount}</span>`;
    document.getElementById('statusPanel').insertBefore(
      techEl, 
      document.getElementById('hazardDisplay')
    );
  } else if (existingTech) {
    existingTech.querySelector('span:last-child').textContent = techCount;
  }
  
  updateScoreboard();
  
  DoomsdayClock.update();
}

// Update UI colours based on DEFCON. Called by updateDisplay().  The colour gradually
// shifts from calm blue/green at DEFCON 5 to intense red at DEFCON 1.
function updateDefconUIColor() {
  const ratio = (5 - S.defcon) / 4;
  const r = Math.round(0 + ratio * 255);
  const g = Math.round(200 - ratio * 200);
  const b = Math.round(255 - ratio * 255);
  const colour = `rgb(${r},${g},${b})`;
  const defconEl = document.getElementById('defcon') || document.getElementById('doomsdayPanel');
  if (defconEl) {
    defconEl.style.color = colour;
    defconEl.style.borderColor = colour;
  }
  const hud = document.getElementById('gameHud');
  if (hud) {
    hud.style.borderColor = colour;
  }
}

function showDefconChange(level) {
  const existing = document.getElementById('defconOverlay');
  if (existing) existing.remove();
  const colours = {
    5: 'var(--cyan)',
    4: 'var(--green)',
    3: 'var(--yellow)',
    2: 'var(--amber)',
    1: 'var(--red)'
  };
  const div = document.createElement('div');
  div.id = 'defconOverlay';
  div.style.cssText = `
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    font-size: 72px;
    color: ${colours[level] || 'var(--cyan)'};
    text-shadow: 0 0 20px ${colours[level] || 'var(--cyan)'};
    pointer-events: none;
    z-index: 10000;
  `;
  div.textContent = 'DEFCON ' + level;
  document.body.appendChild(div);
  setTimeout(() => div.remove(), 1500);
}

function updateScoreboard() {
  const scoreList = document.getElementById('scoreList');
  if (!scoreList) return;
  scoreList.innerHTML = '';
  
  const sorted = [...nations].sort((a, b) => b.population - a.population);
  sorted.forEach(n => {
    const entry = document.createElement('div');
    entry.className = 'score-entry';
    entry.innerHTML = `<span style="color:${n.color}">${n.name}</span><span>${Math.floor(n.population)}M</span>`;
    scoreList.appendChild(entry);
  });
}

/// ============ FIXED ACTION FUNCTIONS ============

function actBuild() {
  AudioSys.playSFX('beep');
  const player = PlayerManager.get();
  if (!player) return;
  
  const cityCost = getCityCost(player);
  
  let html = '<div class="modal-grid">';
  
  html += `<button class="modal-btn" data-k="missile" ${!canAfford(player, COSTS.missile) ? 'disabled' : ''}>
    BUILD MISSILE<br>
    <small>Cost: 8 PRODUCTION</small>
  </button>`;
  
  html += `<button class="modal-btn" data-k="bomber" ${!canAfford(player, COSTS.bomber) ? 'disabled' : ''}>
    BUILD BOMBER<br>
    <small>Cost: 20 PRODUCTION<br>Can carry 2 warheads</small>
  </button>`;
  
  html += `<button class="modal-btn" data-k="defense" ${!canAfford(player, COSTS.defense) ? 'disabled' : ''}>
    UPGRADE DEFENSE<br>
    <small>Cost: 15 PRODUCTION<br>+10% intercept chance</small>
  </button>`;

  // Allow construction of submarines only after the research has been completed.
  if (player.researched?.submarines) {
    html += `<button class="modal-btn" data-k="submarine" ${!canAfford(player, COSTS.submarine) ? 'disabled' : ''}>
      BUILD SUBMARINE<br>
      <small>Cost: ${COSTS.submarine.production} PROD, ${COSTS.submarine.uranium} URAN, ${COSTS.submarine.intel} INTEL</small>
    </button>`;
  }
  
  html += `<button class="modal-btn" data-k="city" ${!canAfford(player, cityCost) ? 'disabled' : ''}>
    BUILD CITY<br>
    <small>Cost: ${cityCost.production} PRODUCTION<br>+10 prod/turn, +3 uranium/turn</small>
  </button>`;
  
  [10, 20, 50, 100].forEach(mt => {
    const cost = COSTS[`warhead_${mt}`];
    html += `<button class="modal-btn" data-k="warhead_${mt}" ${!canAfford(player, cost) ? 'disabled' : ''}>
      BUILD ${mt}MT WARHEAD<br>
      <small>Cost: ${cost.production} PROD, ${cost.uranium} URAN</small>
    </button>`;
  });

  // Rebuild city option
  html += `<button class="modal-btn" data-k="rebuild_city" ${!canAfford(player, {production:50, uranium:5, intel:0}) ? 'disabled' : ''}>
    REBUILD CITY<br>
    <small>Restore destroyed city<br>Cost: 50 PROD, 5 URANIUM</small>
  </button>`;
  
  html += '</div>';
  openModal('BUILD', html);
  
  [...document.querySelectorAll('.modal-btn')].forEach(b => {
    const k = b.dataset.k;
    b.onclick = () => {
      AudioSys.playSFX('beep');
      let built = false;
      
      if (k === 'missile' && canAfford(player, COSTS.missile)) {
        pay(player, COSTS.missile);
        player.missiles++;
        log('Built 1 missile');
        built = true;
      } else if (k === 'bomber' && canAfford(player, COSTS.bomber)) {
        pay(player, COSTS.bomber);
        player.bombers = (player.bombers || 0) + 1;
        log('Built 1 bomber');
        built = true;
      } else if (k === 'defense' && canAfford(player, COSTS.defense)) {
        pay(player, COSTS.defense);
        player.defense += 2;
        log('Defense upgraded (+10% intercept)');
        built = true;
      } else if (k === 'city') {
        const cost = getCityCost(player);
        if (canAfford(player, cost)) {
          pay(player, cost);
          player.cities = (player.cities || 1) + 1;
          
          // FIX 4: Visual city on map
          const spread = 8;
          const angle = Math.random() * Math.PI * 2;
          const newLat = player.lat + Math.sin(angle) * spread;
          const newLon = player.lon + Math.cos(angle) * spread;
          CityLights.addCity(newLat, newLon, 1.2);
          
          log(`Built city #${player.cities} (cost: ${cost.production} prod)`);
          built = true;
        }
      } else if (k.startsWith('warhead_')) {
        const mt = parseInt(k.split('_')[1]);
        const cost = COSTS[k];
        if (canAfford(player, cost)) {
          pay(player, cost);
          player.warheads = player.warheads || {};
          player.warheads[mt] = (player.warheads[mt] || 0) + 1;
          log(`Built ${mt}MT warhead`);
          built = true;
        }
      } else if (k === 'submarine') {
        // Build a submarine if research is complete
        const cost = COSTS.submarine;
        if (player.researched?.submarines && canAfford(player, cost)) {
          pay(player, cost);
          player.submarines = (player.submarines || 0) + 1;
          log('Built 1 submarine (provides one instant strike)');
          built = true;
        }
      } else if (k === 'rebuild_city') {
        if (canAfford(player, {production:50, uranium:5, intel:0})) {
          pay(player, {production:50, uranium:5, intel:0});
          const restored = CityLights.rebuildNear(player.lon, player.lat);
          if (restored > 0) {
            player.population += restored * 5;
            log(`Rebuilt ${restored} cities! +${restored * 5}M population`);
            built = true;
          } else {
            log('No destroyed cities to rebuild nearby', 'warning');
          }
        }
      }
      
      if (built) {
        // Play a dedicated build sound effect when any construction completes
        try { AudioSys.playSFX('build'); } catch(_){ }
        closeModal();
        updateDisplay();
        consumeAction();
      } else {
        log('Not enough resources!', 'warning');
      }
    };
  });
}

function actResearch() {
  const costs = TECH_COSTS;
  // Use a dedicated research sound effect to distinguish this action from
  // generic button presses.  The melodic twinkle reinforces the sense of
  // progress when starting a research session.
  AudioSys.playSFX('research');
  const player = PlayerManager.get();
  if (!player) return;
  
  let html = '<h4>RESEARCH POINTS: ' + (player.intel || 0) + '</h4>';
  html += '<div style="display:grid;gap:10px">';
  
  html += '<div style="border:1px solid rgba(100,255,100,0.5);padding:8px">';
  html += '<h5 style="color:var(--green);margin:0 0 5px 0">TIER 1 TECHNOLOGY</h5>';
  
  html += `<button class="modal-btn" data-tech="better_missiles" ${player.researched?.better_missiles || player.intel < 10 ? 'disabled' : ''}>
    BETTER MISSILES<br>
    <small>+5% accuracy, Cost: 10 INTEL</small>
  </button>`;
  
  html += `<button class="modal-btn" data-tech="radar" ${player.researched?.radar || player.intel < 10 ? 'disabled' : ''}>
    RADAR NETWORK<br>
    <small>+5% intercept chance, Cost: 10 INTEL</small>
  </button>`;
  
  html += `<button class="modal-btn" data-tech="miniaturization" ${player.researched?.miniaturization || player.intel < 10 ? 'disabled' : ''}>
    MINIATURIZATION<br>
    <small>Warheads cost -20% uranium, Cost: 10 INTEL</small>
  </button>`;
  html += '</div>';
  
  html += '<div style="border:1px solid rgba(255,255,100,0.5);padding:8px">';
  html += '<h5 style="color:var(--yellow);margin:0 0 5px 0">TIER 2 TECHNOLOGY</h5>';
  
  html += `<button class="modal-btn" data-tech="mirv" ${player.researched?.mirv || player.intel < 20 || !player.researched?.better_missiles ? 'disabled' : ''}>
    MIRV TECHNOLOGY<br>
    <small>Missiles split into 3 warheads, Cost: 20 INTEL</small>
  </button>`;
  
  html += `<button class="modal-btn" data-tech="stealth" ${player.researched?.stealth || player.intel < 20 ? 'disabled' : ''}>
    STEALTH BOMBERS<br>
    <small>Half intercept chance, Cost: 20 INTEL</small>
  </button>`;
  
  html += `<button class="modal-btn" data-tech="emp" ${player.researched?.emp || player.intel < 20 ? 'disabled' : ''}>
    EMP WEAPONS<br>
    <small>Disable electronics, Cost: 20 INTEL</small>
  </button>`;
  html += '</div>';
  
  html += '<div style="border:1px solid rgba(255,100,100,0.5);padding:8px">';
  html += '<h5 style="color:var(--red);margin:0 0 5px 0">TIER 3 TECHNOLOGY</h5>';
  
  html += `<button class="modal-btn" data-tech="submarines" ${player.researched?.submarines || player.intel < 30 || !player.researched?.mirv ? 'disabled' : ''}>
    NUCLEAR SUBMARINES<br>
    <small>Instant strike capability, Cost: 30 INTEL</small>
  </button>`;
  
  html += `<button class="modal-btn" data-tech="laser" ${player.researched?.laser || player.intel < 30 || !player.researched?.radar ? 'disabled' : ''}>
    LASER DEFENSE<br>
    <small>+15% intercept chance, Cost: 30 INTEL</small>
  </button>`;
  
  html += `<button class="modal-btn" data-tech="mt100" ${player.researched?.mt100 || player.intel < 30 ? 'disabled' : ''}>
    100MT WARHEADS<br>
    <small>Ultimate destruction, Cost: 30 INTEL</small>
  </button>`;
  html += '</div>';
  
  html += '</div>';
  
  openModal('RESEARCH & DEVELOPMENT', html);
  
  [...document.querySelectorAll('.modal-btn[data-tech]')].forEach(btn => {
    btn.onclick = () => {
      const tech = btn.dataset.tech;
      
      if (player.intel >= costs[tech] && !player.researched?.[tech]) {
        player.intel -= costs[tech];
        player.researched = player.researched || {};
        player.researched[tech] = true;
        
        switch(tech) {
          case 'radar':
          case 'laser':
            player.defense += tech === 'laser' ? 3 : 1;
            break;
          case 'mt100':
            player.warheads = player.warheads || {};
            player.warheads[100] = (player.warheads[100] || 0) + 2;
            break;
        }
        
        log(`Researched: ${tech.replace(/_/g, ' ').toUpperCase()}`);
        // Play a distinctive sound upon successfully completing research
        try { AudioSys.playSFX('researchComplete'); } catch(_) {}
        closeModal();
        updateDisplay();
        consumeAction();
      }
    };
  });
}

function actImmigration() {
  AudioSys.playSFX('beep');
  
  let html = '<div class="modal-grid">';
  html += `<button class="modal-btn" data-k="skilled">
    SKILLED IMMIGRATION<br>
        <small>Steal 5% pop from target → you, +15 instab (target), +1 def (you)<br>Cost: 10 PROD, 5 INTEL</small>
  </button>`;
  html += `<button class="modal-btn" data-k="mass">
    MASS IMMIGRATION<br>
    <small>-10% pop → target, +25-35 instab<br>Cost: 5 PROD, 2 INTEL</small>
  </button>`;
  html += `<button class="modal-btn" data-k="refugee">
    REFUGEE WAVE<br>
    <small>Dump your instability on others<br>Cost: 15 INTEL (Req: 50+ instability)</small>
  </button>`;
  html += `<button class="modal-btn" data-k="brain">
    BRAIN DRAIN<br>
    <small>Steal 3% skilled pop + tech<br>Cost: 20 INTEL</small>
  </button>`;
  html += '</div>';
  
  openModal('IMMIGRATION OPS', html);
  
  [...document.querySelectorAll('.modal-btn')].forEach(b => {
    const mode = b.dataset.k;
    b.onclick = () => {
      const player = PlayerManager.get();
      if (!player) {
        log('Player nation not found!', 'alert');
        return;
      }
      
      AudioSys.playSFX('beep');
      closeModal();
      
      selectTarget('IMMIGRATION TARGET', t => {
        let success = false;
        
        switch(mode) {
          case 'skilled':
            if (canAfford(player, COSTS.immigration_skilled)) {
              const intelDiff = (player.intel || 0) - (t.intel || 0);
              let pct = 0.05 + intelDiff * 0.0002;
              pct = Math.min(0.07, Math.max(0.03, pct));
              const amt = Math.max(1, Math.floor(t.population * pct));
              t.population = Math.max(0, t.population - amt);
              player.population += amt;
              player.immigrants = (player.immigrants || 0) + amt;
              t.emigrants = (t.emigrants || 0) + amt;

              t.instability = (t.instability || 0) + 15;
              player.defense += 1;

              pay(player, COSTS.immigration_skilled);
              log(`Skilled immigration: +${amt}M from ${t.name} (+15 instab to ${t.name}, +1 def to you)`);
              success = true;

              addImmigrationIcon(player.lon ?? 0, player.lat ?? 0, player.color, true);
              AudioSys.playSFX('immigration');
            }
            break;
            
          case 'mass':
            if (canAfford(player, COSTS.immigration_mass)) {
              const amt = Math.floor(player.population * 0.10);
              player.population -= amt;
              t.population += amt;
              // Record incoming migrants to the target nation
              t.immigrants = (t.immigrants || 0) + amt;
              // Track migrant flow statistics for intel reports
              t.migrantsThisTurn = (t.migrantsThisTurn || 0) + amt;
              t.migrantsTotal = (t.migrantsTotal || 0) + amt;
              const instab = 25 + Math.floor(Math.random() * 11);
              t.instability = (t.instability || 0) + instab;
              pay(player, COSTS.immigration_mass);
              log(`Mass immigration: ${amt}M → ${t.name} (+${instab} instab)`);
              // Create refugee camp visual for incoming migrants
              createRefugeeCamp(player, t, Math.floor(amt / 10));
              success = true;
              // Use a persistent icon so that waves of migrants are represented continuously.
              addImmigrationIcon(t.lon ?? 0, t.lat ?? 0, player.color, true);
              AudioSys.playSFX('immigration');
            }
            break;
            
          case 'refugee':
            if (canAfford(player, COSTS.immigration_refugee) && (player.instability || 0) >= 50) {
              const amt = Math.floor(player.population * 0.15);
              player.population -= amt;
              t.population += amt;
              // Record incoming migrants to the target nation
              t.immigrants = (t.immigrants || 0) + amt;
              // Track migrant flow statistics for intel reports
              t.migrantsThisTurn = (t.migrantsThisTurn || 0) + amt;
              t.migrantsTotal = (t.migrantsTotal || 0) + amt;
              t.instability = (t.instability || 0) + 40;
              player.instability = Math.max(0, player.instability - 20);
              pay(player, COSTS.immigration_refugee);
              log(`Refugee wave: ${amt}M → ${t.name} (+40 instab, your instab -20)`);
              // Create refugee camp visual for refugees
              createRefugeeCamp(player, t, Math.floor(amt / 10));
              success = true;
              // Place a persistent icon at the destination nation to visualise the arriving refugees. 
              // Even though the refugee camp is drawn separately, the icon provides an immediate
              // pictogram next to the city.  Use the player's colour to differentiate.
              addImmigrationIcon(t.lon ?? 0, t.lat ?? 0, player.color, true);
              AudioSys.playSFX('immigration');
            }
            break;
            
          case 'brain':
            if (canAfford(player, COSTS.immigration_brain)) {
              const amt = Math.floor(t.population * 0.03);
              t.population -= amt;
              player.population += amt;
              // Record incoming migrants to your nation from brain drain
              player.immigrants = (player.immigrants || 0) + amt;
              // Track migrant flow statistics for the player nation
              player.migrantsThisTurn = (player.migrantsThisTurn || 0) + amt;
              player.migrantsTotal = (player.migrantsTotal || 0) + amt;
              t.instability = (t.instability || 0) + 10;
              pay(player, COSTS.immigration_brain);
              log(`Brain drain: +${amt}M skilled from ${t.name}`);
              success = true;
              // Add a small immigration icon to show skilled workers arriving at the player's nation
              addImmigrationIcon(player.lon ?? 0, player.lat ?? 0, player.color, false);
              AudioSys.playSFX('immigration');
            }
            break;
        }
        
        if (!success) {
          log('Not enough resources or requirements not met!', 'warning');
        } else {
          updateDisplay();
          consumeAction();
        }
      });
    };
  });
}

function actIntel() {
  // Play a sonar-like sound when opening the intelligence menu.  This
  // reinforces the feeling of scanning for information.
  AudioSys.playSFX('intel');
  const player = PlayerManager.get();
  if (!player) return;
  
  let html = '<div class="modal-grid">';
  
  html += `<button class="modal-btn" data-k="satellite" ${player.intel < 5 ? 'disabled' : ''}>
    DEPLOY SATELLITE<br>
    <small>Reveal enemy arsenal, Cost: 5 INTEL</small>
  </button>`;
  
  html += `<button class="modal-btn" data-k="sabotage" ${player.intel < 10 ? 'disabled' : ''}>
    SABOTAGE<br>
    <small>Destroy enemy warhead, Cost: 10 INTEL</small>
  </button>`;
  
  html += `<button class="modal-btn" data-k="propaganda" ${player.intel < 15 ? 'disabled' : ''}>
    PROPAGANDA<br>
    <small>+20 enemy instability, Cost: 15 INTEL</small>
  </button>`;
  
  html += `<button class="modal-btn" data-k="culture_bomb" ${player.intel < 20 ? 'disabled' : ''}>
    CULTURE BOMB<br>
    <small>Steal 10% population, Cost: 20 INTEL</small>
  </button>`;
  
  html += `<button class="modal-btn" data-k="view">
    VIEW INTELLIGENCE<br>
    <small>See current intel reports</small>
  </button>`;

  // Advanced intelligence options.  Deep reconnaissance reveals
  // additional details such as researched technologies and AI
  // personalities.  Cover operations temporarily hide your own
  // missiles and resources from enemy satellites.
  html += `<button class="modal-btn" data-k="deep" ${player.intel < 30 ? 'disabled' : ''}>
    DEEP RECON<br>
    <small>Reveal enemy research & doctrine (Cost: 30 INTEL)</small>
  </button>`;
  html += `<button class="modal-btn" data-k="cover" ${player.intel < 25 ? 'disabled' : ''}>
    COVER OPS<br>
    <small>Hide your assets for 3 turns (Cost: 25 INTEL)</small>
  </button>`;
  
  html += '</div>';
  
  openModal('INTELLIGENCE OPS', html);
  
  [...document.querySelectorAll('.modal-btn')].forEach(b => {
    const mode = b.dataset.k;
    b.onclick = () => {
      AudioSys.playSFX('beep');
      
      if (mode === 'view') {
        // Build a report of nations under surveillance.  Only list nations
        // that the player currently has a satellite over.  Each report
        // shows basic demographics along with sensitive statistics such as
        // missile counts, defence levels, warheads, production, uranium,
        // intel stockpiles and migrant flows.  Without surveillance no
        // information is revealed.
        let intelHtml = '<h4>INTELLIGENCE REPORTS</h4>';
        nations.filter(n => !n.isPlayer).forEach(nation => {
          // You must have an active satellite over a nation AND that nation
          // must not be running cover operations to view sensitive data.
          const hasSatellite = !!(player.satellites?.[nation.id]);
          const notHidden = !(nation.coverOpsTurns && nation.coverOpsTurns > 0);
          if (!hasSatellite || !notHidden) return;
          const warheadsStr = Object.entries(nation.warheads || {})
            .map(([k, v]) => `${k}MT×${v}`).join(', ') || '—';
          const hasDeep = player.deepRecon && player.deepRecon[nation.id] > 0;
          intelHtml += `<div style="margin:8px 0;padding:6px;border:1px solid rgba(124,255,107,0.3);">
            <strong>${nation.name}</strong><br>
            <small>POP ${Math.floor(nation.population)}M • CITIES ${nation.cities || 1} • INSTAB ${Math.floor(nation.instability || 0)}</small><br>
            <div style="margin-top:4px">
              MISSILES: ${nation.missiles} | DEFENSE: ${nation.defense}<br>
              WARHEADS: ${warheadsStr}<br>
              PRODUCTION: ${Math.floor(nation.production || 0)} | URANIUM: ${Math.floor(nation.uranium || 0)} | INTEL: ${Math.floor(nation.intel || 0)}<br>
              MIGRANTS (THIS TURN / TOTAL): ${(nation.migrantsThisTurn || 0)} / ${(nation.migrantsTotal || 0)}
              ${hasDeep ? `<br>TECHS: ${Object.keys(nation.researched || {}).join(', ') || 'None'}` : ''}
              ${hasDeep ? `<br>DOCTRINE: ${nation.doctrine || 'Unknown'} • PERSONALITY: ${nation.ai || 'Unknown'}` : ''}
            </div>
          </div>`;
        });
        if (!player.satellites || Object.keys(player.satellites).length === 0) {
          intelHtml += '<p>No active surveillance</p>';
        }
        openModal('INTELLIGENCE REPORT', intelHtml);
        return;
      }
      
      closeModal();
      
      selectTarget('SELECT TARGET', t => {
        let success = false;
        
        switch(mode) {
          case 'satellite':
            if (player.intel >= 5) {
              player.intel -= 5;
              player.satellites = player.satellites || {};
              player.satellites[t.id] = true;
              log(`Satellite deployed over ${t.name}`);
              success = true;
            }
            break;
            
          case 'sabotage':
            if (player.intel >= 10) {
              const warheadTypes = Object.keys(t.warheads || {}).filter(k => t.warheads[k] > 0);
              if (warheadTypes.length > 0) {
                const type = warheadTypes[Math.floor(Math.random() * warheadTypes.length)];
                t.warheads[type]--;
                if (t.warheads[type] <= 0) delete t.warheads[type];
                player.intel -= 10;
                log(`Sabotage: Destroyed ${t.name}'s ${type}MT warhead`);
                success = true;
              }
            }
            break;
            
          case 'propaganda':
            if (player.intel >= 15) {
              t.instability = (t.instability || 0) + 20;
              player.intel -= 15;
              log(`Propaganda campaign: ${t.name} instability +20`);
              success = true;
            }
            break;
            
          case 'culture_bomb':
            if (player.intel >= 20) {
              const stolen = Math.floor(t.population * 0.1);
              t.population -= stolen;
              player.population += stolen;
              player.intel -= 20;
              log(`Culture bomb: Stole ${stolen}M from ${t.name}`);
              success = true;
            }
            break;

          case 'deep':
            // Deep reconnaissance reveals a nation's researched
            // technologies and doctrine/personality for several
            // turns.  It also places a satellite if one does not
            // already exist.  The operation costs 30 INTEL.
            if (player.intel >= 30) {
              player.intel -= 30;
              player.satellites = player.satellites || {};
              player.satellites[t.id] = true;
              player.deepRecon = player.deepRecon || {};
              player.deepRecon[t.id] = (player.deepRecon[t.id] || 0) + 3;
              log(`Deep recon initiated over ${t.name}: detailed intel available for 3 turns`);
              success = true;
            }
            break;
          case 'cover':
            // Cover operations hide your own military and resource
            // information from all satellites for 3 turns.  It costs
            // 25 INTEL.  During cover ops, other nations cannot see
            // your missiles, warheads, production, uranium or intel
            // values.
            if (player.intel >= 25) {
              player.intel -= 25;
              player.coverOpsTurns = (player.coverOpsTurns || 0) + 3;
              log(`Cover operations commenced: your assets hidden for 3 turns`);
              success = true;
            }
            break;
        }
        
        if (success) {
          updateDisplay();
          // Play a feedback sound to mark a successful diplomatic action
          try { AudioSys.playSFX('diplomacy'); } catch(_) {}
          consumeAction();
        } else {
          log('Not enough resources!', 'warning');
        }
      });
    };
  });
}

// Shared diplomacy action handler so AI and players obey identical costs and effects
function performDiplomaticAction(actor, target, mode) {
  const isPlayer = actor === PlayerManager.get();
  switch(mode) {
    case 'truce':
      actor.treaties = actor.treaties || {};
      target.treaties = target.treaties || {};
      actor.treaties[target.id] = {truceTurns: 2};
      target.treaties[actor.id] = {truceTurns: 2};
      log(isPlayer ? `Truce declared with ${target.name} (2 turns)` : `${actor.name} declares truce with ${target.name} (2 turns)`);
      return true;

    case 'trade':
      if (actor.sanctioned || actor.production < 10) return false;
      actor.production -= 10;
      actor.uranium += 5;
      log(isPlayer ? `Trade with ${target.name}: -10 PROD, +5 URANIUM` : `${actor.name} trades with ${target.name}`);
      return true;

    case 'alliance':
      if (actor.intel >= 40 && actor.production >= 10) {
        actor.intel -= 40;
        actor.production -= 10;
        actor.treaties = actor.treaties || {};
        target.treaties = target.treaties || {};
        actor.treaties[target.id] = {alliance: true, truceTurns: 999};
        target.treaties[actor.id] = {alliance: true, truceTurns: 999};
        log(isPlayer ? `Alliance formed with ${target.name}!` : `${actor.name} forms alliance with ${target.name}`);
        return true;
      }
      return false;

    case 'sanction':
      if (actor.intel >= 15) {
        actor.intel -= 15;
        target.sanctioned = true;
        target.sanctionTurns = 5;
        log(isPlayer ? `Trade sanctions imposed on ${target.name} (5 turns)` : `${actor.name} sanctions ${target.name} (5 turns)`);
        return true;
      }
      return false;

    case 'pact':
      if (actor.intel >= 15) {
        actor.intel -= 15;
        actor.treaties = actor.treaties || {};
        target.treaties = target.treaties || {};
        actor.treaties[target.id] = {truceTurns: 5};
        target.treaties[actor.id] = {truceTurns: 5};
        log(isPlayer ? `Non-aggression pact with ${target.name} (5 turns)` : `${actor.name} signs non-aggression pact with ${target.name} (5 turns)`);
        return true;
      }
      return false;

    case 'aid':
      if (actor.production >= 20) {
        actor.production -= 20;
        target.instability = Math.max(0, (target.instability || 0) - 10);
        log(isPlayer ? `Economic aid sent to ${target.name}: -10 instability` : `${actor.name} sends economic aid to ${target.name}`);
        return true;
      }
      return false;

    case 'propaganda':
      if (actor.intel >= 15) {
        actor.intel -= 15;
        target.intel = Math.max(0, (target.intel || 0) - 10);
        actor.intel += 5;
        log(isPlayer ? `Propaganda campaign against ${target.name}: drained 10 intel, gained 5 intel` : `${actor.name} runs propaganda against ${target.name}`);
        return true;
      }
      return false;

    case 'env':
      if (actor.production >= 15 && actor.intel >= 60) {
        actor.production -= 15;
        actor.intel -= 60;
        target.environmentPenaltyTurns = (target.environmentPenaltyTurns || 0) + 5;
        log(isPlayer ? `Environmental treaty with ${target.name}: production/uranium reduced for 5 turns` : `${actor.name} enforces environmental treaty on ${target.name}`);
        return true;
      }
      return false;
  }
  return false;
}

function actDiplomacy() {
  // A two-tone handshake sound signals the start of diplomatic negotiations.
  AudioSys.playSFX('diplomacy');
  const player = PlayerManager.get();
  if (!player) return;
  
  let html = '<div class="modal-grid">';
  
  html += `<button class="modal-btn" data-k="truce">
    DECLARE TRUCE<br>
    <small>2 turns no attacks (mutual)</small>
  </button>`;
  
  html += `<button class="modal-btn" data-k="trade" ${player.production < 10 ? 'disabled' : ''}>
    TRADE AGREEMENT<br>
    <small>Give 10 PROD → Get 5 URANIUM</small>
  </button>`;
  
  html += `<button class="modal-btn" data-k="un" ${player.intel < 10 ? 'disabled' : ''}>
    UN APPEAL<br>
    <small>DEFCON +1, Cost: 10 INTEL</small>
  </button>`;
  
  html += `<button class="modal-btn" data-k="alliance" ${(player.intel < 40 || player.production < 10) ? 'disabled' : ''}>
    FORM ALLIANCE<br>
    <small>Share intel, can't attack, Cost: 10 PROD, 40 INTEL</small>
  </button>`;
  
  html += `<button class="modal-btn" data-k="backstab">
    BACKSTAB<br>
    <small>Break truce, +1 missile, +10 instability</small>
  </button>`;
  
  html += `<button class="modal-btn" data-k="borders" ${player.intel < 5 ? 'disabled' : ''}>
    CLOSE BORDERS<br>
    <small>Block immigration 2 turns, Cost: 5 INTEL</small>
  </button>`;

  html += `<button class="modal-btn" data-k="sanction" ${player.intel < 15 ? 'disabled' : ''}>
    IMPOSE SANCTIONS<br>
    <small>Block target from trading, Cost: 15 INTEL</small>
  </button>`;

  // Additional diplomacy options
  html += `<button class="modal-btn" data-k="pact" ${player.intel < 15 ? 'disabled' : ''}>
    NON-AGGRESSION PACT<br>
    <small>5 turns no attacks, Cost: 15 INTEL</small>
  </button>`;
  html += `<button class="modal-btn" data-k="aid" ${player.production < 20 ? 'disabled' : ''}>
    ECONOMIC AID<br>
    <small>Give 20 PROD → Reduce target instability by 10</small>
  </button>`;
  html += `<button class="modal-btn" data-k="propaganda" ${player.intel < 15 ? 'disabled' : ''}>
    PROPAGANDA<br>
    <small>Use 15 INTEL → Drain 10 INTEL from target</small>
  </button>`;

  // Environmental treaty forces an opponent to phase out nuclear power
  // plants, reducing their production and uranium gains for several
  // turns.  This action requires a large investment of both
  // production and intel.  See productionPhase() for the debuff
  // implementation.
  html += `<button class="modal-btn" data-k="env" ${(player.production < 15 || player.intel < 60) ? 'disabled' : ''}>
    ENV TREATY<br>
    <small>Phase-out nuclear power (−30% PROD, −30% URAN, 5 turns) — Cost: 15 PROD & 60 INTEL</small>
  </button>`;

  // Note: duplicate entries for pact/aid/propaganda removed.  See earlier definitions for these actions.
  
  html += '</div>';
  
  openModal('DIPLOMACY', html);
  
  [...document.querySelectorAll('.modal-btn')].forEach(b => {
    const mode = b.dataset.k;
    b.onclick = () => {
      AudioSys.playSFX('beep');
      
      if (mode === 'un') {
        if (player.intel >= 10 && S.defcon < 5) {
          player.intel -= 10;
          S.defcon++;
          DoomsdayClock.improve(0.5);
          log(`UN Appeal successful: DEFCON improved to ${S.defcon}`);
          closeModal();
          updateDisplay();
          consumeAction();
        } else {
          log('Cannot improve DEFCON further or not enough intel', 'warning');
        }
        return;
      }
      
      if (mode === 'backstab') {
        const truces = Object.keys(player.treaties || {}).filter(id => player.treaties[id]?.truceTurns > 0);
        if (truces.length === 0) {
          log('No active truces to break', 'warning');
          return;
        }
        const target = nations.find(n => n.id === truces[0]);
        player.treaties[truces[0]].truceTurns = 0;
        player.missiles++;
        player.instability = (player.instability || 0) + 10;
        log(`Backstabbed ${target.name}! +1 missile, +10 instability`);
        closeModal();
        updateDisplay();
        consumeAction();
        return;
      }
      
      if (mode === 'borders') {
        if (player.intel >= 5) {
          player.intel -= 5;
          player.bordersClosedTurns = 2;
          log('Borders closed for 2 turns');
          closeModal();
          updateDisplay();
          consumeAction();
        }
        return;
      }
      
      closeModal();

      selectTarget('SELECT NATION', t => {
        const success = performDiplomaticAction(player, t, mode);
        if (success) {
          updateDisplay();
          consumeAction();
        } else {
          log('Not enough resources!', 'warning');
        }
      });
    };
  });
}

function actCulture() {
  // Culture actions use a playful sequence of beeps to underscore their
  // whimsical nature.
  AudioSys.playSFX('culture');
  const player = PlayerManager.get();
  if (!player) return;
  
  let html = '<div class="modal-grid">';
  
  html += `<button class="modal-btn" data-k="meme" ${player.intel < 2 ? 'disabled' : ''}>
    MEME WAVE<br>
    <small>Steal 5M pop, +8 instability, Cost: 2 INTEL</small>
  </button>`;
  
  html += `<button class="modal-btn" data-k="cancel" ${player.intel < 3 ? 'disabled' : ''}>
    CANCEL CAMPAIGN<br>
    <small>Target +4 instability, Cost: 3 INTEL</small>
  </button>`;
  
  html += `<button class="modal-btn" data-k="deepfake" ${player.intel < 5 ? 'disabled' : ''}>
    DEEPFAKE OPS<br>
    <small>Target defense -2, Cost: 5 INTEL</small>
  </button>`;
  
  html += `<button class="modal-btn" data-k="victory" ${player.intel < 50 ? 'disabled' : ''}>
    PROPAGANDA VICTORY<br>
    <small>Win if >50% culture, Cost: 50 INTEL</small>
  </button>`;

  // Environmental campaign: encourage your opponent to abandon nuclear power and
  // heavy industry.  Applies a lasting production debuff to the target at
  // relatively low intel cost.
  html += `<button class="modal-btn" data-k="eco" ${(player.intel < 150 || player.production < 30) ? 'disabled' : ''}>
    ECO PROPAGANDA<br>
    <small>Force nuclear phase-out (−40% PRODUCTION, −50% URANIUM, 5 turns) — Cost: 30 PROD, 150 INTEL</small>
  </button>`;
  
  html += '</div>';
  
  openModal('CULTURE WARFARE', html);
  
  [...document.querySelectorAll('.modal-btn')].forEach(b => {
    const mode = b.dataset.k;
    b.onclick = () => {
      AudioSys.playSFX('beep');
      
      if (mode === 'victory') {
        const totalIntel = nations.reduce((sum, n) => sum + (n.intel || 0), 0);
        if (player.intel >= 50 && player.intel / totalIntel > 0.5) {
          endGame(true, 'CULTURAL VICTORY - Minds conquered without firing a shot!');
        } else {
          log('Need >50% of world culture to win', 'warning');
        }
        return;
      }
      
      closeModal();
      
      selectTarget('CULTURE TARGET', t => {
        let success = false;
        
        switch(mode) {
          case 'meme':
            if (player.intel >= 2) {
              const stolen = Math.min(5, t.population);
              t.population -= stolen;
              player.population += stolen;
              t.instability = (t.instability || 0) + 8;
              player.intel -= 2;
              log(`Meme Wave on ${t.name}: -${stolen}M, instability +8`);
              success = true;
            }
            break;
            
          case 'cancel':
            if (player.intel >= 3) {
              t.instability = (t.instability || 0) + 4;
              player.intel -= 3;
              log(`Cancel Campaign on ${t.name}: instability +4`);
              success = true;
            }
            break;
            
          case 'deepfake':
            if (player.intel >= 5) {
              t.defense = Math.max(0, t.defense - 2);
              player.intel -= 5;
              log(`Deepfake Ops on ${t.name}: defense -2`);
              success = true;
            }
            break;

          case 'eco':
            // Environmental propaganda now costs 150 intel and 30 production.  Applies a
            // temporary production and uranium debuff for 5 turns.  Debuffs are applied each production phase.
            if (player.intel >= 150 && player.production >= 30) {
              t.greenShiftTurns = (t.greenShiftTurns || 0) + 5;
              player.intel -= 150;
              player.production -= 30;
              log(`Eco propaganda on ${t.name}: nuclear phase-out for 5 turns (−PROD, −URAN)`);
              success = true;
            }
            break;
        }
        
        if (success) {
          updateDisplay();
          consumeAction();
        } else {
          log('Not enough resources!', 'warning');
        }
      });
    };
  });
}

// FIXED actAttack with bomber/submarine support
function actAttack() {
  // A tense warble introduces an attack sequence to heighten suspense.
  AudioSys.playSFX('attack');
  const player = PlayerManager.get();
  if (!player) return;

  if (S.defcon > 2) {
    log('Attacks require DEFCON 2 or lower!', 'warning');
    return;
  }

  // First choose delivery method
  let html = '<h4>SELECT DELIVERY METHOD</h4><div class="modal-grid">';

  // Missiles
  if (player.missiles > 0) {
    html += `<button class="modal-btn" data-method="missile">
      MISSILE STRIKE<br>
      <small>${player.missiles} available, 1 turn flight</small>
    </button>`;
  }

  // Bombers
  if ((player.bombers || 0) > 0) {
    html += `<button class="modal-btn" data-method="bomber">
      BOMBER STRIKE<br>
      <small>${player.bombers} available, 2-3 turn flight, can be intercepted</small>
    </button>`;
  }

  // Submarines (if researched)
  // Submarines (if researched).  Only show the button if at least one
  // submarine is available; otherwise disable it.
  if (player.researched?.submarines) {
    const disabled = !(player.submarines > 0);
    html += `<button class="modal-btn" data-method="submarine" ${disabled ? 'disabled' : ''}>
      SUBMARINE STRIKE<br>
      <small>Instant strike, no intercept, uses warhead only</small>
    </button>`;
  }

  html += '</div>';

  if (!player.missiles && !player.bombers && !player.researched?.submarines) {
    log('No delivery methods available!', 'warning');
    return;
  }

  openModal('SELECT DELIVERY', html);

  [...document.querySelectorAll('.modal-btn[data-method]')].forEach(b => {
    const method = b.dataset.method;
    b.onclick = () => {
      closeModal();

      // Now select warhead
      let warheadHtml = '<h4>SELECT WARHEAD</h4><div class="modal-grid">';
      Object.entries(player.warheads || {}).forEach(([mt, count]) => {
        if (count > 0) {
          warheadHtml += `<button class="modal-btn" data-mt="${mt}">${mt}MT (x${count})</button>`;
        }
      });
      warheadHtml += '</div>';

      openModal('SELECT WARHEAD', warheadHtml);

      [...document.querySelectorAll('.modal-btn[data-mt]')].forEach(wb => {
        const mt = parseInt(wb.dataset.mt);
        wb.onclick = () => {
          closeModal();
          selectTarget('SELECT TARGET', t => {
            let success = false;

            if (method === 'missile') {
              success = launch(player, t, mt);
            } else if (method === 'bomber') {
              if (player.bombers > 0 && player.warheads[mt] > 0) {
                player.bombers--;
                player.warheads[mt]--;
                if (player.warheads[mt] <= 0) delete player.warheads[mt];
                launchBomber(player, t, {yield: mt});
                log(`🛩️ Bomber launched at ${t.name} with ${mt}MT warhead (2-3 turns)`, 'warning');
                AudioSys.playSFX('launch');
                success = true;
              }
            } else if (method === 'submarine') {
              // Require an available submarine for each launch
              if ((player.submarines || 0) > 0 && player.warheads[mt] > 0) {
                player.submarines--;
                player.warheads[mt]--;
                if (player.warheads[mt] <= 0) delete player.warheads[mt];
                // Launch submarine animation and missile
                launchSubmarine(player, t, mt);
                log(`🚢 SUBMARINE LAUNCH! ${mt}MT missile launched at ${t.name}!`, 'alert');
                DoomsdayClock.tick(0.4);
                success = true;
              }
            }

            if (success) {
              updateDisplay();
              consumeAction();
            } else {
              log('Attack failed - check resources!', 'warning');
            }
          });
        };
      });
    };
  });
}

function selectTarget(title, callback) {
  let html = '<div class="modal-grid">';
  nations.filter(n => !n.isPlayer && n.population > 0).forEach(n => {
    html += `<button class="modal-btn" data-id="${n.id}">${n.name} - ${Math.floor(n.population)}M</button>`;
  });
  html += '</div>';
  
  openModal(title, html);
  
  [...document.querySelectorAll('.modal-btn[data-id]')].forEach(b => {
    const id = b.dataset.id;
    b.onclick = () => {
      const target = nations.find(n => n.id === id);
      closeModal();
      callback(target);
    };
  });
}

function consumeAction() {
  S.actionsRemaining--;
  updateDisplay();

  if (S.actionsRemaining <= 0) {
    S.overlay={text:'NEXT ROUND', ttl:1000};
    setTimeout(endTurn, 500);
  }
}

// AI diplomacy helper: returns true if an action was performed
function aiDiplomacy(n) {
  const threatEntries = Object.entries(n.threats || {}).sort((a, b) => b[1] - a[1]);
  const enemy = threatEntries.length ? nations.find(t => t.id === threatEntries[0][0]) : null;

  if (enemy) {
    if (n.intel >= 15 && Math.random() < 0.3) {
      if (performDiplomaticAction(n, enemy, 'sanction')) return true;
    }
    if (n.intel >= 15 && Math.random() < 0.3) {
      if (performDiplomaticAction(n, enemy, 'propaganda')) return true;
    }
    if (!(n.treaties?.[enemy.id]?.truceTurns > 0) && n.intel >= 15 && Math.random() < 0.2) {
      if (performDiplomaticAction(n, enemy, 'pact')) return true;
    }
  }

  const allyNeedingAid = nations.find(t => n.treaties?.[t.id]?.alliance && (t.instability || 0) > 15);
  if (allyNeedingAid && n.production >= 20 && Math.random() < 0.4) {
    if (performDiplomaticAction(n, allyNeedingAid, 'aid')) return true;
  }

  return false;
}

/// ============ AI TURN ============
function aiTurn(n) {
  S.overlay={text:'AI: '+(n.leader||n.name), ttl:800};
  if (n.population <= 0) return;

  maybeBanter(n, 0.3);

  // --- Diplomacy Evaluation ---
  // If this nation feels threatened and has the resources, attempt to form
  // an alliance with another nation that shares its enemy.  This adds a layer
  // of strategic diplomacy instead of random pacts.
  const threatEntries = Object.entries(n.threats || {}).sort((a, b) => b[1] - a[1]);
  if (threatEntries.length > 0) {
    const [enemyId, threatVal] = threatEntries[0];
    const enemy = nations.find(t => t.id === enemyId);
    // Only consider alliances when the threat is significant and resources allow.
    if (threatVal > 20 && enemy) {
      const potentialAllies = nations.filter(t => t !== n && t.id !== enemyId && t.population > 0 && !n.treaties?.[t.id]?.alliance);
      if (potentialAllies.length > 0 && n.intel >= 40 && n.production >= 10) {
        // Score potential allies by shared threat toward the enemy and their stance
        const score = t => (t.threats?.[enemyId] || 0) - (t.threats?.[n.id] || 0) + (t.ai === 'defensive' ? 5 : 0);
        potentialAllies.sort((a, b) => score(b) - score(a));
        const ally = potentialAllies[0];
        if (score(ally) > 0 && Math.random() < 0.6) {
          if (performDiplomaticAction(n, ally, 'alliance')) {
            maybeBanter(n, 0.4, 'diplomacy');
            return;
          }
        }
      }
    }
  }

  // If no alliance formed, attempt other diplomatic actions
  if (aiDiplomacy(n)) return;

  const r = Math.random();
  // Aggression modifiers adjust the baseline probability of launching an attack.
  // Aggressive AI is more likely to strike, defensive less so.  New
  // personalities like balanced and isolationist further reduce the
  // likelihood of unprovoked aggression.
  let aggressionMod = 0;
  if (n.ai === 'aggressive') aggressionMod = 0.2;
  else if (n.ai === 'defensive') aggressionMod = -0.1;
  else if (n.ai === 'balanced') aggressionMod = 0.0;
  else if (n.ai === 'isolationist') aggressionMod = -0.2;
  
  if (r < 0.3 + aggressionMod && S.defcon <= 2) {
    const targets = nations.filter(t => t !== n && t.population > 0 && !n.treaties?.[t.id]?.truceTurns);
    if (targets.length > 0) {
      // Sort potential targets based on accumulated threat and defenses.  AI
      // personalities weight threat differently: isolationists heavily
      // prioritise retaliation, aggressive AIs consider even mild threats
      // provocation, while balanced types take a moderate approach.  A
      // small bias is added toward the player to maintain pressure on the
      // human opponent.
      const target = targets.sort((a,b) => {
        const compute = (t) => {
          const threat = n.threats ? (n.threats[t.id] || 0) : 0;
          let score = threat;
          const aiType = n.ai || '';
          if (aiType === 'balanced') score *= 1.0;
          else if (aiType === 'isolationist') score *= 1.5;
          else if (aiType === 'aggressive') score *= 1.2;
          // Defensive weighting for targets with high intercept capability
          const defWeight = aiType === 'aggressive' ? 0.4 : aiType === 'balanced' ? 0.6 : aiType === 'isolationist' ? 0.8 : 0.5;
          score -= (t.defense || 0) * defWeight;
          // Slight preference to attack the player to keep gameplay tense
          if (t.isPlayer) score += 5;
          return score;
        };
        return compute(b) - compute(a);
      })[0];
      
      const warheadTypes = Object.keys(n.warheads || {}).filter(k => n.warheads[k] > 0);
      if (warheadTypes.length > 0 && n.missiles > 0) {
        const yieldMT = parseInt(warheadTypes[0]);
        
        if ((yieldMT <= 50 && S.defcon <= 2) || (yieldMT > 50 && S.defcon === 1)) {
          n.warheads[yieldMT]--;
          if (n.warheads[yieldMT] <= 0) delete n.warheads[yieldMT];
          n.missiles--;
          
          launch(n, target, yieldMT);
          log(`${n.name} launches ${yieldMT}MT at ${target.name}`);
          maybeBanter(n, 0.7, 'launch');
          
          if (target.isPlayer) {
            maybeBanter(n, 0.5, 'reactive_hit');
          }
        }
      }
    }
  } else if (r < 0.5) {
    // Build using the same options available to the player
    const opts = [];

    if (canAfford(n, COSTS.missile)) {
      opts.push(() => { pay(n, COSTS.missile); n.missiles++; log(`${n.name} builds missile`); });
    }
    if (canAfford(n, COSTS.bomber)) {
      opts.push(() => { pay(n, COSTS.bomber); n.bombers = (n.bombers || 0) + 1; log(`${n.name} builds bomber`); });
    }
    [10,20,50,100].forEach(mt => {
      if (mt === 100 && !n.researched?.mt100) return;
      const cost = COSTS[`warhead_${mt}`];
      if (canAfford(n, cost)) {
        opts.push(() => {
          pay(n, cost);
          n.warheads = n.warheads || {};
          n.warheads[mt] = (n.warheads[mt] || 0) + 1;
          log(`${n.name} builds ${mt}MT warhead`);
        });
      }
    });
    if (n.researched?.submarines && canAfford(n, COSTS.submarine)) {
      opts.push(() => {
        pay(n, COSTS.submarine);
        n.submarines = (n.submarines || 0) + 1;
        log(`${n.name} builds submarine`);
      });
    }

    if (opts.length) {
      const action = opts[Math.floor(Math.random() * opts.length)];
      action();
      maybeBanter(n, 0.2, 'build');
    }
  } else if (r < 0.7) {
    if (canAfford(n, COSTS.defense)) {
      pay(n, COSTS.defense);
      n.defense += 2;
      log(`${n.name} upgrades defense`);
    } else {
      const cityCost = getCityCost(n);
      if (canAfford(n, cityCost)) {
        pay(n, cityCost);
        n.cities++;

        // Add visual city for AI too
        const spread = 6;
        const angle = Math.random() * Math.PI * 2;
        const newLat = n.lat + Math.sin(angle) * spread;
        const newLon = n.lon + Math.cos(angle) * spread;
        CityLights.addCity(newLat, newLon, 1.0);

        log(`${n.name} builds city #${n.cities}`);
        maybeBanter(n, 0.3, 'build');
      }
    }
    } else if (r < 0.85 && canAfford(n, COSTS.immigration_skilled)) {
      const targets = nations.filter(t => t !== n && t.population > 1);
      if (targets.length > 0) {
        const target = targets[Math.floor(Math.random() * targets.length)];
        pay(n, COSTS.immigration_skilled);
        const base = Math.floor(Math.random() * 3) + 1;
        let chance = 60;
        chance = Math.min(95, Math.max(5, chance));
        const roll = Math.random() * 100;
        let amt = 0;
        if (roll >= 95) {
          amt = Math.ceil(base * 1.5);
          target.instability = (target.instability || 0) + 25;
        } else if (roll >= chance) {
          amt = base;
          target.instability = (target.instability || 0) + 15;
        } else if (roll >= 40) {
          amt = Math.max(1, Math.floor(base / 2));
          target.instability = (target.instability || 0) + 5;
        } else if (roll < 25) {
          n.instability = (n.instability || 0) + 10;
        }
        amt = Math.min(amt, target.population - 1);
        if (amt > 0) {
          target.population -= amt;
          n.population += amt;
          addImmigrationIcon(n.lon ?? 0, n.lat ?? 0, n.color, false);
          log(`${n.name} steals ${amt}M skilled from ${target.name}`);
        } else {
          log(`${n.name} failed immigration op against ${target.name}`);
        }
        maybeBanter(n, 0.5, 'immigration');
      }
    } else if (r < 0.95) {
    // Research technologies following the same tree as the player
    const order = ['better_missiles', 'radar', 'miniaturization', 'mirv', 'stealth', 'emp', 'submarines', 'laser', 'mt100'];
    const canResearch = tech => {
      if (tech === 'mirv') return n.researched?.better_missiles;
      if (tech === 'submarines') return n.researched?.mirv;
      if (tech === 'laser') return n.researched?.radar;
      return true;
    };
    const choices = order.filter(t => !n.researched?.[t] && n.intel >= TECH_COSTS[t] && canResearch(t));
    if (choices.length) {
      const tech = choices[Math.floor(Math.random() * choices.length)];
      n.intel -= TECH_COSTS[tech];
      n.researched = n.researched || {};
      n.researched[tech] = true;
      if (tech === 'radar') n.defense += 1;
      else if (tech === 'laser') n.defense += 3;
      else if (tech === 'mt100') {
        n.warheads = n.warheads || {};
        n.warheads[100] = (n.warheads[100] || 0) + 2;
      }
      log(`${n.name} researches ${tech.replace(/_/g, ' ')}`);
    }
  } else {
    if (Math.random() < 0.5 && S.defcon > 1) {
      S.defcon--;
      log(`${n.name} escalates to DEFCON ${S.defcon}`);
      maybeBanter(n, 0.4);
    }
  }
}

/// ============ END TURN ============
function endTurn() {
  // Prevent ending the turn if it's not currently the player's phase or the game is over.
  if (S.gameOver || S.phase !== 'PLAYER') return;
  
  S.actionsRemaining = 0;
  
  S.phase = 'AI';
  updateDisplay();
  
  const aiNations = nations.filter(n => !n.isPlayer && n.population > 0);
  const actionsPerAI = S.defcon >= 4 ? 1 : S.defcon >= 2 ? 2 : 3;
  
  let aiActionCount = 0;
  aiNations.forEach(ai => {
    for (let i = 0; i < actionsPerAI; i++) {
      setTimeout(() => aiTurn(ai), 500 * aiActionCount++);
    }
  });
  
  setTimeout(() => {
    S.phase = 'RESOLUTION';
    updateDisplay();
    resolutionPhase();
    
    setTimeout(() => {
      S.phase = 'PRODUCTION';
      productionPhase();
      
      S.turn++;
      S.phase = 'PLAYER';
      S.actionsRemaining = S.defcon >= 4 ? 1 : S.defcon >= 2 ? 2 : 3;
      
      updateDisplay();
      checkVictory();
    }, 1500);
  }, aiActionCount * 500 + 500);
}

/// ============ VICTORY CONDITIONS ============
function checkVictory() {
  if (S.gameOver) return;
  
  const player = PlayerManager.get();
  if (!player) return;
  
  const alive = nations.filter(n => n.population > 0);
  const totalPop = alive.reduce((sum, n) => sum + n.population, 0);
  
  if (player.population <= 0) {
    endGame(false, 'Your nation has been destroyed');
    return;
  }
  
  if (DoomsdayClock.minutes <= 0) {
    endGame(false, 'MUTUAL ASSURED DESTRUCTION');
    return;
  }
  
  if (alive.length === 1 && alive[0] === player) {
    endGame(true, 'TOTAL DOMINATION - You are the sole survivor!');
    return;
  }
  
  if (player.cities >= 10) {
    endGame(true, 'ECONOMIC VICTORY - Industrial supremacy achieved!');
    return;
  }
  
  if (player.population / totalPop > 0.6 && player.instability < 30) {
    endGame(true, 'DEMOGRAPHIC VICTORY - You control the world through immigration!');
    return;
  }
  
  if (S.turn >= 50 && player.population >= 50) {
    const score = S.turn * 10 + player.population * 5 + player.missiles * 20;
    endGame(true, `SURVIVAL VICTORY - Endured 50 turns! Score: ${score}`);
    return;
  }
}

function endGame(victory, message) {
  S.gameOver = true;
  
  const score = S.turn * 10 + (PlayerManager.get()?.population || 0) * 5;
  
  document.getElementById('endTitle').textContent = victory ? 'VICTORY' : 'DEFEAT';
  document.getElementById('endText').innerHTML = `
    <p>${message}</p>
    <p>Survived ${S.turn} turns</p>
    <p>Score: ${Math.floor(score)}</p>
  `;
  
  document.getElementById('endGame').style.display = 'flex';

  const playerObj = PlayerManager.get();
  const playerName = S.playerName || S.selectedLeader || playerObj?.leader || 'PLAYER';
  const doctrine = playerObj?.doctrine || S.selectedDoctrine || 'NONE';
  const highscores = JSON.parse(Storage.getItem('highscores') || '[]');
  highscores.push({score, turns: S.turn, date: new Date().toISOString(), name: playerName, doctrine});
  highscores.sort((a, b) => b.score - a.score);
  Storage.setItem('highscores', JSON.stringify(highscores.slice(0, 10)));
}

/// ============ MODAL ============
function openModal(title, content) {
  document.getElementById('modalTitle').textContent = title;
  document.getElementById('modalBody').innerHTML = content;
  document.getElementById('modal').style.display = 'flex';
}

function closeModal() {
  document.getElementById('modal').style.display = 'none';
}

/// ============ GAME LOOP ============
function gameLoop() {
  if(S.paused || S.gameOver) {
    requestAnimationFrame(gameLoop);
    return;
  }
  
  ctx.fillStyle = '#000000';
  ctx.fillRect(0, 0, W, H);

  // Update and draw atmospheric effects (clouds, stars) behind the world
  Atmosphere.update();
  Atmosphere.draw(ctx);

  // Draw animated ocean waves behind the world
  Ocean.update();
  Ocean.draw(ctx);
  
  cam.zoom += (cam.targetZoom - cam.zoom) * 0.1;
  
  drawWorld();
  CityLights.draw(ctx);
  drawNations();
  drawMissiles();
  drawBombers();
  drawSubmarines();
  drawRefugeeCamps();
  // Draw immigration icons (fade-out markers placed when immigration actions occur)
  drawImmigrationIcons();
  drawParticles();
  drawFX();
  
  requestAnimationFrame(gameLoop);
}

/// ============ START SCREEN ANIMATION ============
function animateStartScreen() {
  startCtx.fillStyle = '#000000';
  startCtx.fillRect(0, 0, W, H);
  
  if(worldCountries) {
    startCtx.save();
    startCtx.strokeStyle = 'rgba(0,255,255,0.1)';
    startCtx.lineWidth = 1;
    
    worldCountries.features.forEach(feature => {
      startCtx.beginPath();
      const coords = feature.geometry.coordinates;
      
      if(feature.geometry.type === 'Polygon') {
        drawStartPath(startCtx, coords[0], 0.5);
      } else if(feature.geometry.type === 'MultiPolygon') {
        coords.forEach(poly => drawStartPath(startCtx, poly[0], 0.5));
      }
      
      startCtx.stroke();
    });
    startCtx.restore();
  }
  
  if(Math.random() < 0.02) {
    const sx = Math.random() * W;
    const sy = H;
    const tx = Math.random() * W;
    const ty = Math.random() * H * 0.6;
    
    startCtx.strokeStyle = 'rgba(255,0,0,0.5)';
    startCtx.lineWidth = 2;
    startCtx.beginPath();
    startCtx.moveTo(sx, sy);
    startCtx.quadraticCurveTo((sx+tx)/2, ty-100, tx, ty);
    startCtx.stroke();
    
    startCtx.fillStyle = 'rgba(255,255,0,0.3)';
    startCtx.beginPath();
    startCtx.arc(tx, ty, 20, 0, Math.PI * 2);
    startCtx.fill();
  }
  
  startCtx.strokeStyle = 'rgba(0,255,255,0.05)';
  startCtx.lineWidth = 1;
  for(let x = 0; x < W; x += 50) {
    startCtx.beginPath();
    startCtx.moveTo(x, 0);
    startCtx.lineTo(x, H);
    startCtx.stroke();
  }
  for(let y = 0; y < H; y += 50) {
    startCtx.beginPath();
    startCtx.moveTo(0, y);
    startCtx.lineTo(W, y);
    startCtx.stroke();
  }
  
  if(document.getElementById('start').style.display !== 'none') {
    requestAnimationFrame(animateStartScreen);
  }
}

function drawStartPath(context, coords, scale = 1) {
  coords.forEach((coord, i) => {
    const x = ((coord[0] + 180) / 360) * W * scale + W * (1-scale) / 2;
    const y = ((90 - coord[1]) / 180) * H * scale + H * (1-scale) / 2;
    if(i === 0) context.moveTo(x, y);
    else context.lineTo(x, y);
  });
}

/// ============ START MENU ============
window.addEventListener('DOMContentLoaded', () => {
  // FIX 2: Continue Button with Save Info
  const continueBtn = document.getElementById('continueBtn');
  if(Storage.getItem('save')) {
    try {
      const saveData = JSON.parse(Storage.getItem('save'));
      continueBtn.style.display = 'inline-block';
      continueBtn.innerHTML = `CONTINUE<br><small style="opacity:0.7;font-size:10px">Turn ${saveData.state?.turn || '?'} - ${saveData.state?.selectedLeader || 'Unknown'}</small>`;
      continueBtn.onclick = () => {
        // Load save
        Object.assign(S, saveData.state);
        nations = saveData.nations;
        document.getElementById('start').style.display = 'none';
        
        document.getElementById('gameHud').style.display = 'flex';
        document.getElementById('resourcePanel').style.display = 'block';
        document.getElementById('doomsdayPanel').style.display = 'block';
        document.getElementById('scorePanel').style.display = 'block';
        document.getElementById('statusPanel').style.display = 'block';
        document.getElementById('log').style.display = 'block';
        
        CityLights.generate();
        updateDisplay();
        setupGameButtons();
        loadWorld();
      };
    } catch(e) {
      continueBtn.style.display = 'none';
    }
  }
  
  const newGameBtn = document.getElementById('newGameBtn');
  if(newGameBtn) {
    newGameBtn.onclick = () => {
      if (AudioSys?.audioContext && AudioSys.audioContext.state === 'suspended') { AudioSys.audioContext.resume(); }
      document.querySelector('.start-menu').style.display = 'none';
      document.getElementById('leaderSelect').style.display = 'block';
      
      const grid = document.getElementById('leaderGrid');
      grid.innerHTML = '';
      
      leaders.forEach(leader => {
        const card = document.createElement('div');
        card.className = 'leader-card';
        card.innerHTML = `
          <div class="leader-name">${leader.name}</div>
          <div class="leader-ai">${leader.ai}</div>
        `;
        card.onclick = () => selectLeader(leader.name);
        grid.appendChild(card);
      });
      
      // FIX: Center custom leader card
      // Add invisible spacers
      for(let i = 0; i < 2; i++) {
        const spacer = document.createElement('div');
        spacer.style.visibility = 'hidden';
        spacer.style.pointerEvents = 'none';
        grid.appendChild(spacer);
      }
      
      // Add custom leader option
      const customCard = document.createElement('div');
      customCard.className = 'leader-card';
      customCard.style.borderColor = 'var(--green)';
      customCard.innerHTML = `
        <div class="leader-name" style="color:var(--green)">CREATE CUSTOM</div>
        <div class="leader-ai">Choose your style</div>
      `;
      customCard.onclick = () => {
        document.getElementById('leaderSelect').innerHTML = `
          <h3 style="color:var(--cyan);margin:20px 0">CREATE YOUR LEADER</h3>
          <div style="padding:20px;max-width:400px;margin:0 auto">
            <div style="margin:15px 0">
              <label style="color:var(--green)">Name:</label><br>
              <input type="text" id="customName" maxlength="20" 
                style="background:#000;border:1px solid var(--cyan);color:var(--cyan);
                       padding:5px;width:100%;font-family:monospace">
            </div>
            <div style="margin:15px 0">
              <label style="color:var(--green)">Personality:</label><br>
              <select id="customAI" 
                style="background:#000;border:1px solid var(--cyan);color:var(--cyan);
                       padding:5px;width:100%;font-family:monospace">
                <option value="balanced">Balanced</option>
                <option value="aggressive">Aggressive</option>
                <option value="defensive">Defensive</option>
                <option value="trickster">Trickster</option>
                <option value="chaotic">Chaotic</option>
              </select>
            </div>
            <button class="start-btn" onclick="
              const name = document.getElementById('customName').value.trim();
              if(!name) {alert('Enter a name!'); return;}
              S.selectedLeader = name;
              S.playerName = name;
              selectLeader(name);
            ">CREATE</button>
          </div>
        `;
      };
      grid.appendChild(customCard);
    };
  }
  
  const startOptionsBtn = document.getElementById('startOptionsBtn');
  if(startOptionsBtn) {
    startOptionsBtn.onclick = showOptionsModal;
  }
  
  const highscoresBtn = document.getElementById('highscoresBtn');
  if(highscoresBtn) {
    highscoresBtn.onclick = () => {
      const highscores = JSON.parse(Storage.getItem('highscores') || '[]');
      let html = '<h4>TOP 10 HIGHSCORES</h4>';
      html += '<div style="max-height:400px;overflow-y:auto">';
      
      if(highscores.length === 0) {
        html += '<p style="color:var(--cyan);text-align:center">No highscores yet!</p>';
      } else {
        highscores.forEach((score, i) => {
          const date = new Date(score.date).toLocaleDateString();
          html += `<div style="display:flex;justify-content:space-between;flex-wrap:wrap;padding:8px;border-bottom:1px solid rgba(0,255,255,0.2)">
            <span style="color:var(--green)">#${i+1}</span>
            <span style="color:var(--cyan)">${Math.floor(score.score)} pts</span>
            <span style="color:var(--mag)">${score.name || '—'}</span>
            <span style="color:var(--yellow)">${(score.doctrine || '—').toUpperCase()}</span>
            <span style="color:var(--mag)">Turn ${score.turns}</span>
            <span style="color:var(--amber);font-size:10px">${date}</span>
          </div>`;
        });
      }
      
      html += '</div>';
      openModal('HIGHSCORES', html);
    };
  }

  // Tutorial button handler: open the comprehensive rules/guide when clicked
  const tutorialBtnEl = document.getElementById('tutorialBtn');
  if (tutorialBtnEl) {
    tutorialBtnEl.onclick = showTutorial;
  }
});

function selectLeader(name) {
  S.selectedLeader = name;
  S.playerName = S.playerName || name; // Preserve custom name
  document.getElementById('leaderSelect').style.display = 'none';
  document.getElementById('doctrineSelect').style.display = 'block';
  
  const grid = document.getElementById('doctrineGrid');
  grid.innerHTML = '';
  
  Object.entries(doctrines).forEach(([key, doctrine]) => {
    const card = document.createElement('div');
    card.className = 'doctrine-card';
    card.innerHTML = `
      <div class="doctrine-name">${doctrine.name}</div>
      <div class="doctrine-desc">${doctrine.desc}</div>
      <div class="doctrine-effects">${doctrine.effects}</div>
    `;
    card.onclick = () => selectDoctrine(key);
    grid.appendChild(card);
  });
}

function selectDoctrine(key) {
  S.selectedDoctrine = key;
  document.getElementById('doctrineSelect').style.display = 'none';
  document.getElementById('difficultySelect').style.display = 'block';
}

function startGame(difficulty) {
  S.difficulty = difficulty;
  document.getElementById('start').style.display = 'none';
  
  document.getElementById('gameHud').style.display = 'flex';
  document.getElementById('resourcePanel').style.display = 'block';
  document.getElementById('doomsdayPanel').style.display = 'block';
  document.getElementById('scorePanel').style.display = 'block';
  document.getElementById('statusPanel').style.display = 'block';
  document.getElementById('log').style.display = 'block';
  
  initNations();
  CityLights.generate();
  // Initialize atmospheric effects (clouds and stars) once when the game starts
  Atmosphere.init();
  S.phase = 'PLAYER';
  S.actionsRemaining = S.defcon >= 4 ? 1 : S.defcon >= 2 ? 2 : 3;
  updateDisplay();
  setupGameButtons();
  loadWorld();
}

/// ============ GAME BUTTONS ============
function setupGameButtons() {
  document.getElementById('actBuild').onclick = actBuild;
  document.getElementById('actResearch').onclick = actResearch;
  document.getElementById('actIntel').onclick = actIntel;
  document.getElementById('actCulture').onclick = actCulture;
  document.getElementById('actImmigration').onclick = actImmigration;
  document.getElementById('actDiplomacy').onclick = actDiplomacy;
  document.getElementById('actAttack').onclick = actAttack;
  document.getElementById('turnBtn').onclick = endTurn;
  
  document.getElementById('pauseBtn').onclick = () => {
    S.paused = !S.paused;
    document.getElementById('pauseBtn').textContent = S.paused ? '▶' : '||';
  };
  
  document.getElementById('saveBtn').onclick = () => {
    try {
      const saveData = JSON.stringify({
        version: 'v1-complete',
        state: S,
        nations,
        timestamp: Date.now()
      });
      
      if (saveData.length > 5000000) {
        log('Save data too large!', 'warning');
        return;
      }
      
      Storage.setItem('save', saveData);
      log('Game saved', 'success');
    } catch(e) {
      log('Save failed: ' + e.message, 'alert');
    }
  };
  
  document.getElementById('optionsBtn').onclick = showOptionsModal;

  // Hook up fullscreen toggle button in the HUD
  const fsBtn = document.getElementById('fullscreenBtn');
  if (fsBtn) {
    fsBtn.onclick = toggleFullscreen;
  }
}

function showOptionsModal() {
  // Compose the options modal starting with theme selections.  Wrap the
  // buttons so they flow cleanly on narrower screens.  Additional
  // themes like night mode and high contrast offer improved
  // accessibility.
  let html = '<h4>THEME</h4>';
  html += '<div style="display:flex;justify-content:center;flex-wrap:wrap;gap:20px;margin:20px 0">';
  html += `<button class="btn" onclick="applyTheme('synthwave')">SYNTHWAVE</button>`;
  html += `<button class="btn" onclick="applyTheme('retro80s')">RETRO 80s</button>`;
  html += `<button class="btn" onclick="applyTheme('wargames')">WARGAMES</button>`;
  html += `<button class="btn" onclick="applyTheme('nightmode')">NIGHT MODE</button>`;
  html += `<button class="btn" onclick="applyTheme('highcontrast')">HIGH CONTRAST</button>`;
  html += '</div>';
  // Font selection section.  Each button applies a different font via
  // applyFont().  The wrappers mirror the theme layout for consistency.
  html += '<h4 style="margin-top:20px">FONTS</h4>';
  html += '<div style="display:flex;justify-content:center;flex-wrap:wrap;gap:20px;margin:20px 0">';
  html += `<button class="btn" onclick="applyFont('retro')">RETRO</button>`;
  html += `<button class="btn" onclick="applyFont('sans')">SANS-SERIF</button>`;
  html += `<button class="btn" onclick="applyFont('modern')">MODERN</button>`;
  html += '</div>';
  // Now begin the audio section header.  The existing audio controls
  // follow below.
  html += '<h4 style="margin-top:20px">AUDIO</h4>';
  html += '<div style="display:flex;justify-content:center;gap:20px;margin:20px 0">';
  html += `<button class="btn" onclick="AudioSys.toggleMusic();this.textContent='MUSIC: '+(AudioSys.musicEnabled?'ON':'OFF')">MUSIC: ${AudioSys.musicEnabled?'ON':'OFF'}</button>`;
  html += `<button class="btn" onclick="AudioSys.toggleSFX();this.textContent='SFX: '+(AudioSys.sfxEnabled?'ON':'OFF')">SFX: ${AudioSys.sfxEnabled?'ON':'OFF'}</button>`;
  html += '</div>';
  html += '<div style="margin:10px 0">';
  html += `<label style="color:var(--cyan)">Music Volume: <span id="volDisplay">${Math.round(AudioSys.musicVolume * 100)}%</span></label><br>`;
  html += `<input type="range" min="0" max="100" value="${AudioSys.musicVolume * 100}" 
    style="width:200px;margin:10px 0" 
    oninput="AudioSys.setMusicVolume(this.value/100);document.getElementById('volDisplay').textContent=this.value+'%'">`;
  html += '</div>';
  html += '<p style="font-size:10px;color:var(--amber);margin:10px 0">🎵 Music: Place norad.mp3 in same folder</p>';
  html += '<h4 style="margin-top:20px">FX</h4>';
  html += '<div style="margin:10px 0">';
  html += `<label style="color:var(--cyan)">FX Intensity: <span id="fxDisplay">${Math.round((S.fx||1)*100)}%</span></label><br>`;
  html += `<input type="range" min="0" max="100" value="${Math.round((S.fx||1)*100)}"
    style="width:200px;margin:10px 0"
    oninput="S.fx=this.value/100;document.getElementById('fxDisplay').textContent=this.value+'%'">`;
  html += '</div>';

  // UI scale adjustment: allow the player to scale the entire interface.  The slider
  // ranges from 50% to 150%.  When moved, it updates the body's zoom, stores
  // the scale in Storage, and updates the displayed percentage.  A separate
  // heading groups this control for clarity.
  html += '<h4 style="margin-top:20px">UI SCALE</h4>';
  html += '<div style="margin:10px 0">';
  html += `<label style="color:var(--cyan)">UI Scale: <span id="uiScaleDisplay">${Math.round((window.uiScale||1)*100)}%</span></label><br>`;
  html += `<input type="range" min="50" max="150" value="${Math.round((window.uiScale||1)*100)}"
    style="width:200px;margin:10px 0"
    oninput="updateUIScaleSlider(this.value)">`;
  html += '</div>';

  // Event cards toggle.  Allows the player to choose whether random
  // events produce on‑screen cards.  The button text reflects the
  // current state.  Clicking toggles the preference and updates the
  // label accordingly.
  html += '<h4 style="margin-top:20px">EVENT CARDS</h4>';
  html += '<div style="margin:10px 0">';
  html += `<button class="btn" onclick="toggleEventCards(); this.textContent='EVENT CARDS: '+(eventCardEnabled?'ON':'OFF')">EVENT CARDS: ${eventCardEnabled?'ON':'OFF'}</button>`;
  html += '</div>';

  // Assistance section.  Offer an interactive tutorial for hands‑on
  // learning and a button to open the static game guide.  Placed
  // before the GAME utilities for prominence.
  html += '<h4 style="margin-top:20px">ASSISTANCE</h4>';
  html += '<div style="display:flex;justify-content:center;flex-wrap:wrap;gap:20px;margin:20px 0">';
  html += `<button class="btn" onclick="startInteractiveTutorial()">INTERACTIVE TUTORIAL</button>`;
  html += `<button class="btn" onclick="showTutorial()">GAME GUIDE</button>`;
  html += '</div>';
  html += '<h4 style="margin-top:20px">GAME</h4>';
  html += '<div style="display:flex;justify-content:center;gap:20px;margin:20px 0">';
  html += `<button class="btn" onclick="Storage.removeItem('worldMapCache');alert('Map cache cleared!')">CLEAR MAP CACHE</button>`;
  html += `<button class="btn" onclick="Storage.removeItem('highscores');alert('Highscores reset!')">RESET HIGHSCORES</button>`;
  html += `<button class="btn" onclick="quitToTitle()">QUIT TO TITLE</button>`;
  html += '</div>';
  openModal('OPTIONS', html);
}

// Toggle fullscreen mode for the application.  When entering fullscreen the canvas
// automatically resizes via resizeCanvas(); exiting fullscreen restores normal
// windowed mode.  Bound to the ⛶ button in the HUD.
function toggleFullscreen() {
  if (!document.fullscreenElement) {
    document.documentElement.requestFullscreen?.();
    // Immediately resize canvas to match new dimensions
    setTimeout(resizeCanvas, 50);
  } else {
    document.exitFullscreen?.();
    setTimeout(resizeCanvas, 50);
  }
}

// Display a comprehensive tutorial and rule overview.  Opens a modal with
// detailed information on objectives, DEFCON, resources, actions, victory
// conditions, instability mechanics, controls, and strategic tips.
function showTutorial() {
  let html = `
    <div style="max-height:70vh;overflow-y:auto;padding-right:10px">
    
    <h4 style="color:var(--cyan);margin:15px 0">🎯 OBJECTIVE</h4>
    <p>Survive nuclear war through strategy, diplomacy, or total domination. Multiple victory paths available.</p>
    
    <h4 style="color:var(--green);margin:15px 0">🔥 DEFCON SYSTEM</h4>
    <p><strong>DEFCON 5-4:</strong> 1 action/turn, no attacks<br>
    <strong>DEFCON 3-2:</strong> 2 actions/turn, tactical nukes allowed<br>
    <strong>DEFCON 1:</strong> 3 actions/turn, strategic weapons unleashed</p>
    
    <h4 style="color:var(--red);margin:15px 0">⏰ DOOMSDAY CLOCK</h4>
    <p>Starts at 7:00, ticks down with escalation. At 0:00 = MUTUAL ASSURED DESTRUCTION!</p>
    
    <h4 style="color:var(--mag);margin:15px 0">💰 RESOURCES</h4>
    <p><strong>Production:</strong> Build missiles, bombers, cities<br>
    <strong>Uranium:</strong> Create nuclear warheads<br>
    <strong>Intel:</strong> Research tech, spy operations, culture war</p>
    
    <h4 style="color:var(--yellow);margin:15px 0">🔬 TECH TREE</h4>
    <p><strong>Tier 1 (10 Intel):</strong> Better Missiles, Radar, Miniaturization<br>
    <strong>Tier 2 (20 Intel):</strong> MIRV, Stealth Bombers, EMP<br>
    <strong>Tier 3 (30 Intel):</strong> Nuclear Subs, Laser Defense, 100MT</p>
    
    <h4 style="color:var(--amber);margin:15px 0">⚔️ COMBAT</h4>
    <p><strong>Missiles:</strong> 1 turn flight, can be intercepted<br>
    <strong>Bombers:</strong> 2-3 turn flight, detected midway<br>
    <strong>Submarines:</strong> Instant strike, limited ammo (research for more)</p>
    
    <h4 style="color:var(--cyan);margin:15px 0">🎭 ACTIONS</h4>
    <div style="font-size:10px;line-height:1.4">
    <strong>BUILD:</strong> Missiles, bombers, defense, cities, warheads<br>
    <strong>RESEARCH:</strong> Unlock tech tree advances<br>
    <strong>INTEL:</strong> Satellites, sabotage, hacking<br>
    <strong>CULTURE:</strong> Meme warfare, propaganda victory<br>
    <strong>IMMIGRATION:</strong> Skilled/mass/refugee waves<br>
    <strong>DIPLOMACY:</strong> Truces, trades, alliances<br>
    <strong>ATTACK:</strong> Nuclear strikes via missile/bomber/sub
    </div>
    
    <h4 style="color:var(--green);margin:15px 0">🏆 VICTORY CONDITIONS</h4>
    <p><strong>Domination:</strong> Last nation standing<br>
    <strong>Survival:</strong> Endure 50 turns with 50M+ population<br>
    <strong>Cultural:</strong> Control >50% of world's intel<br>
    <strong>Economic:</strong> Build 10+ cities</p>
    
    <h4 style="color:var(--red);margin:15px 0">⚡ INSTABILITY</h4>
    <p>Built up by war, immigration, culture ops. At 50+ causes revolts. At 100 = civil war!</p>
    
    <h4 style="color:var(--mag);margin:15px 0">🎮 CONTROLS</h4>
    <p><strong>Mouse:</strong> Drag to pan, scroll to zoom<br>
    <strong>Keyboard:</strong> 1-7 for actions, ENTER = end turn, SPACE = pause, S = save, ESC = options</p>
    
    <h4 style="color:var(--amber);margin:15px 0">💡 STRATEGY TIPS</h4>
    <div style="font-size:10px;line-height:1.3">
    • Early game: Build cities for resource income<br>
    • Mid game: Research key tech (MIRV, Submarines)<br>
    • Late game: Balance offense/defense as clock ticks down<br>
    • Immigration destabilizes enemies without direct war<br>
    • Culture ops can win without firing a shot<br>
    • Watch AI personalities: Aggressive = strike first, Defensive = fortify
    </div>
    
    </div>
  `;
  openModal('HOW TO PLAY NORAD VECTOR', html);
}

// ================= INTERACTIVE TUTORIAL =================
// An object that guides the player through the interface step‑by‑step.
// Each step references a CSS selector and a text description.  When
// started, the tutorial highlights the targeted element and places
// a pop‑up overlay nearby with explanatory text.  Clicking the
// NEXT/DONE button advances or ends the tutorial.  Elements are
// temporarily decorated with .tutorial-highlight via CSS.
const Tutorial = {
  steps: [
    { selector: '.defcon-display', text: 'DEFCON: Indicates the current alert level. Higher numbers are safer; lower numbers allow more actions and nuclear launches.' },
    { selector: '.resources', text: 'Resources: Production builds units, uranium makes warheads, intel fuels research and espionage, cities increase income.' },
    { selector: '#doomsdayPanel', text: 'Doomsday Clock: As conflict escalates, the clock ticks toward midnight. Reach 0 and everyone loses.' },
    { selector: '#scorePanel', text: 'Scoreboard: Ranks all nations by population. Stay on top to win certain victory conditions.' },
    { selector: '.log', text: 'Event Log: Records actions, events and banter. Check here for important alerts.' },
    { selector: '#actBuild', text: 'BUILD: Construct missiles, bombers, defense and cities. Building expands your arsenal and economy.' },
    { selector: '#actResearch', text: 'RESEARCH: Spend intel to unlock new technologies like MIRV, stealth bombers and nuclear submarines.' },
    { selector: '#actDiplomacy', text: 'DIPLOMACY: Negotiate truces, alliances and trade. Use diplomacy to manage aggression without firing a shot.' },
    { selector: '#actAttack', text: 'ATTACK: Launch missiles or bombers at opponents when DEFCON permits. Your warheads must be ready.' }
  ],
  index: 0,
  overlayEl: null,
  active: false,
  start() {
    this.index = 0;
    this.active = true;
    this.showStep();
  },
  showStep() {
    if (!this.active) return;
    const step = this.steps[this.index];
    if (!step) { this.end(); return; }
    // Remove previous highlights and overlays
    document.querySelectorAll('.tutorial-highlight').forEach(el => el.classList.remove('tutorial-highlight'));
    if (this.overlayEl) { this.overlayEl.remove(); this.overlayEl = null; }
    const el = document.querySelector(step.selector);
    if (!el) { this.next(); return; }
    el.classList.add('tutorial-highlight');
    // Compute overlay position
    const rect = el.getBoundingClientRect();
    const ov = document.createElement('div');
    ov.className = 'tutorial-overlay';
    // Insert a close button (X) in the top-right corner of the overlay.  Users can
    // click this at any time to end the tutorial.  Use inline styles for
    // positioning to avoid additional CSS rules.
    const closeBtn = `<button class="btn" id="tutorialCloseBtn" style="position:absolute;top:4px;right:4px;padding:0 6px;font-size:12px;line-height:12px;color:var(--red);border-color:var(--red)">✖</button>`;
    ov.innerHTML = `${closeBtn}<p>${step.text}</p><div style="text-align:right;margin-top:10px"><button class="btn" id="tutorialNextBtn">${this.index < this.steps.length - 1 ? 'NEXT' : 'DONE'}</button></div>`;
    document.body.appendChild(ov);
    // Default placement below the target
    let left = rect.left;
    let top = rect.bottom + 8;
    // If near right edge, place to the left
    if (rect.right + 320 > window.innerWidth) {
      left = Math.max(10, rect.left - 300);
    }
    // If overlay would go off bottom, place above
    if (top + 100 > window.innerHeight) {
      top = rect.top - ov.offsetHeight - 8;
    }
    if (top < 10) top = 10;
    if (left < 10) left = 10;
    ov.style.left = `${left}px`;
    ov.style.top = `${top}px`;
    this.overlayEl = ov;
    document.getElementById('tutorialNextBtn').onclick = () => {
      this.next();
    };
    // Bind the close button to end the tutorial immediately
    const cbtn = document.getElementById('tutorialCloseBtn');
    if (cbtn) {
      cbtn.onclick = () => { this.end(); };
    }
  },
  next() {
    this.index++;
    if (this.index >= this.steps.length) {
      this.end();
    } else {
      this.showStep();
    }
  },
  end() {
    this.active = false;
    document.querySelectorAll('.tutorial-highlight').forEach(el => el.classList.remove('tutorial-highlight'));
    if (this.overlayEl) { this.overlayEl.remove(); this.overlayEl = null; }
  }
};

// Expose a helper to start the interactive tutorial.  This is called from
// the options modal assistance section and can be bound to other UI
// elements if desired.
function startInteractiveTutorial() {
  Tutorial.start();
}

// ================= URGENT EVENTS =================
// Show a pop‑up that requires the player to respond within a time limit.
// If the player clicks RESPOND before the timeout, onSuccess() is
// called; otherwise onFail() executes after the delay.  The overlay
// disappears either way.  Use this for natural disasters and other
// crises that demand quick attention.
let _urgentTimeout = null;
function showUrgentEvent(title, message, onSuccess, onFail, timeoutMs = 10000) {
  const panel = document.getElementById('urgentEvent');
  if (!panel) return;
  document.getElementById('urgentTitle').textContent = title;
  document.getElementById('urgentMessage').textContent = message;
  panel.style.display = 'flex';
  // Clear any existing timeout
  if (_urgentTimeout) {
    clearTimeout(_urgentTimeout);
    _urgentTimeout = null;
  }
  // Set up auto‑fail
  _urgentTimeout = setTimeout(() => {
    panel.style.display = 'none';
    _urgentTimeout = null;
    if (typeof onFail === 'function') onFail();
  }, timeoutMs);
  // Bind respond button
  const btn = document.getElementById('urgentRespondBtn');
  btn.onclick = () => {
    panel.style.display = 'none';
    if (_urgentTimeout) {
      clearTimeout(_urgentTimeout);
      _urgentTimeout = null;
    }
    if (typeof onSuccess === 'function') onSuccess();
  };
}

// ================= EVENT CARDS =================
// Persistent preference for displaying event cards.  Saved in Storage so the
// player's choice persists across sessions.  Enabled by default.
let eventCardEnabled = JSON.parse(Storage.getItem('noradEventCard') ?? 'true');
// Expose the flag on the global window so inline onclick handlers can
// reference it.  Without this assignment the variable remains scoped to
// this module and would not be visible from HTML attributes.
window.eventCardEnabled = eventCardEnabled;

// Toggle the event card display setting.  This is bound to an option in
// the settings menu.  When disabled, random events will no longer pop
// up a card overlay, though their effects and log messages still occur.
function toggleEventCards() {
  eventCardEnabled = !eventCardEnabled;
  window.eventCardEnabled = eventCardEnabled;
  Storage.setItem('noradEventCard', JSON.stringify(eventCardEnabled));
}

// Display an informational card for a random event.  Accepts an event
// identifier, name and optional description.  If event cards are
// disabled, the function does nothing.  Images are looked up in the
// `events/` subdirectory; if not found the image element is hidden.
function showEventCard(evId, title, description = '') {
  if (!eventCardEnabled) return;
  const panel = document.getElementById('eventCard');
  if (!panel) return;
  const imgEl = panel.querySelector('.card-image');
  // Reset image visibility
  if (imgEl) {
    imgEl.style.display = 'block';
    imgEl.src = `events/${evId}.png`;
    imgEl.onerror = () => { imgEl.style.display = 'none'; };
  }
  const titleEl = panel.querySelector('.card-title');
  if (titleEl) titleEl.textContent = title;
  const descEl = panel.querySelector('.card-desc');
  if (descEl) descEl.textContent = description || 'An unexpected event has occurred. Check the log for more details.';
  panel.style.display = 'flex';
}

// Attach a one‑time click handler for closing event cards.  The handler
// references this function so that it remains accessible after patch
// injection.  This is executed on load when the DOM exists.
document.addEventListener('DOMContentLoaded', () => {
  const cbtn = document.querySelector('#eventCard .card-close-btn');
  if (cbtn) {
    cbtn.onclick = () => {
      const panel = document.getElementById('eventCard');
      if (panel) panel.style.display = 'none';
    };
  }
  // Attach close handler to the modal X button.  When clicked, the modal
  // hides via closeModal().  This works alongside the main close button
  // and the Escape key.  We guard against missing elements so
  // additional modals can be inserted without errors.
  const mclose = document.getElementById('modalCloseX');
  if (mclose) {
    mclose.onclick = () => {
      closeModal();
    };
  }
});

function quitToTitle(){
  // Hide game HUD/panels
  document.getElementById('gameHud').style.display='none';
  document.getElementById('resourcePanel').style.display='none';
  document.getElementById('doomsdayPanel').style.display='none';
  document.getElementById('scorePanel').style.display='none';
  document.getElementById('statusPanel').style.display='none';
  document.getElementById('log').style.display='none';
  // Show start
  const start = document.getElementById('start');
  start.style.display='flex';
  const sm = start.querySelector('.start-menu'); if(sm) sm.style.display='block';
  const ls = document.getElementById('leaderSelect'); if(ls) ls.style.display='none';
  const ds = document.getElementById('doctrineSelect'); if(ds) ds.style.display='none';
  const dif = document.getElementById('difficultySelect'); if(dif) dif.style.display='none';
  // Reset minimal state
  S.phase='PLAYER';
  S.actionsRemaining = S.defcon >= 4 ? 1 : S.defcon >= 2 ? 2 : 3;
  S.missiles=[]; S.bombers=[]; S.interceptors=[]; S.explosions=[];
  S.particles=[]; S.smokeTrails=[]; S.radiationZones=[]; S.empEffects=[];
  S.craters=[]; S.flashes=[]; S.rings=[]; S.screenShake=0; S.overlay=null;
  closeModal();

  // Ensure buttons visible
  ['newGameBtn','startOptionsBtn','highscoresBtn'].forEach(id=>{
    const el=document.getElementById(id); if(el) el.style.display='inline-block';
  });
  const cont=document.getElementById('continueBtn');
  if (cont) { try { cont.style.display = Storage.getItem('save') ? 'inline-block' : 'none'; } catch(_) { cont.style.display='none'; } }
  // Remove any 'hidden' classes under #start
  start.querySelectorAll('.hidden').forEach(e=>e.classList.remove('hidden'));
}

/// ============ CONTROLS ============
let isDragging = false;
let dragStart = {x: 0, y: 0};

canvas.addEventListener('mousedown', e => {
  isDragging = true;
  dragStart = {x: e.clientX - cam.x, y: e.clientY - cam.y};
});

canvas.addEventListener('mousemove', e => {
  if(isDragging) {
    cam.x = e.clientX - dragStart.x;
    cam.y = e.clientY - dragStart.y;
  }
});

canvas.addEventListener('mouseup', () => {
  isDragging = false;
});

canvas.addEventListener('wheel', e => {
  e.preventDefault();
  const delta = e.deltaY > 0 ? 0.9 : 1.1;
  cam.targetZoom = Math.max(0.5, Math.min(3, cam.targetZoom * delta));
});

let touching = false;
let touchStart = {x: 0, y: 0};

canvas.addEventListener('touchstart', e => {
  if(e.touches.length === 1) {
    touching = true;
    touchStart = {x: e.touches[0].clientX, y: e.touches[0].clientY};
  }
}, {passive: true});

canvas.addEventListener('touchmove', e => {
  if(!touching) return;
  if(e.touches.length === 1) { 
    const nx = e.touches[0].clientX, ny = e.touches[0].clientY; 
    cam.x += nx - touchStart.x; 
    cam.y += ny - touchStart.y; 
    touchStart = {x: nx, y: ny}; 
  }
}, {passive: true});

canvas.addEventListener('touchend', () => { 
  touching = false; 
}, {passive: true});

// When the player has deployed satellites over a nation, allow clicking the nation's marker on the map
// to open a quick intelligence report.  We ignore clicks while dragging the map or when a modal is open.
canvas.addEventListener('click', e => {
  // Do not process clicks if the user is dragging the map, a modal is open or the game is over
  if (typeof isDragging !== 'undefined' && isDragging) return;
  if (S.gameOver || document.getElementById('modal').style.display === 'flex') return;
  const player = PlayerManager.get();
  if (!player || !player.satellites) return;
  // Determine click coordinates relative to the canvas
  const rect = canvas.getBoundingClientRect();
  const mx = e.clientX - rect.left;
  const my = e.clientY - rect.top;
  // Iterate monitored nations and check proximity to their marker
  for (const n of nations) {
    if (n.isPlayer) continue;
    if (!player.satellites[n.id]) continue;
    if (n.population <= 0) continue;
    const [nx, ny] = project(n.lon, n.lat);
    const dist = Math.hypot(mx - nx, my - ny);
    // Consider a hit within ~20 pixels of the marker
    if (dist < 20) {
      let intelHtml = `<div style="margin:8px 0;padding:6px;border:1px solid rgba(124,255,107,.3);">`;
      intelHtml += `<strong>${n.name}</strong><br>`;
      intelHtml += `Missiles: ${n.missiles} | Defense: ${n.defense}<br>`;
      intelHtml += `Warheads: ${Object.entries(n.warheads || {}).map(([k, v]) => `${k}MT×${v}`).join(', ')}<br>`;
      intelHtml += `Production: ${Math.floor(n.production || 0)} | Uranium: ${Math.floor(n.uranium || 0)} | Intel: ${Math.floor(n.intel || 0)}<br>`;
      intelHtml += `Migrants (This Turn / Total): ${(n.migrantsThisTurn || 0)} / ${(n.migrantsTotal || 0)}<br>`;
      intelHtml += `Population: ${Math.floor(n.population)}M | Instability: ${Math.floor(n.instability || 0)}`;
      intelHtml += `</div>`;
      openModal(`${n.name} INTEL`, intelHtml);
      break;
    }
  }
});

document.addEventListener('keydown', e => {
  if(e.key === 'Escape') {
    if(document.getElementById('modal').style.display === 'flex') {
      closeModal();
    } else {
      document.getElementById('optionsBtn').click();
    }
  }
  
  if(S.gameOver || document.getElementById('start').style.display !== 'none') return;
  
  switch(e.key) {
    case '1': document.getElementById('actBuild').click(); break;
    case '2': document.getElementById('actResearch').click(); break;
    case '3': document.getElementById('actIntel').click(); break;
    case '4': document.getElementById('actCulture').click(); break;
    case '5': document.getElementById('actImmigration').click(); break;
    case '6': document.getElementById('actDiplomacy').click(); break;
    case '7': document.getElementById('actAttack').click(); break;
    case 'Enter': document.getElementById('turnBtn').click(); break;
    case ' ':
      e.preventDefault();
      document.getElementById('pauseBtn').click();
      break;
    case 's':
    case 'S': document.getElementById('saveBtn').click(); break;
  }
});

// ======================= ZOOM AND REGION INFO =======================
// Allow the player to double‑click on the map to zoom into a local region.
// On first double click, the camera zooms in and centres on the clicked
// coordinates, then displays a quick info modal about the nearest nation.
// A subsequent double click resets the zoom to the default scale.
let zoomedIn = false;
canvas.addEventListener('dblclick', e => {
  // ignore zooming if dragging, a modal is open, or the game is not in progress
  if (typeof isDragging !== 'undefined' && isDragging) return;
  if (S.gameOver || document.getElementById('modal').style.display === 'flex') return;
  const rect = canvas.getBoundingClientRect();
  const mx = e.clientX - rect.left;
  const my = e.clientY - rect.top;
  if (zoomedIn) {
    // reset zoom and recenter
    cam.targetZoom = 1;
    cam.zoom = 1;
    cam.x = (W - W * cam.zoom) / 2;
    cam.y = (H - H * cam.zoom) / 2;
    zoomedIn = false;
    return;
  }
  // compute lon/lat of click
  const [lon, lat] = toLonLat(mx, my);
  // increase zoom, clamp to 3x
  const newZoom = Math.min(3, cam.targetZoom * 1.5);
  cam.targetZoom = newZoom;
  cam.zoom = newZoom;
  // centre clicked location
  cam.x = W / 2 - ((lon + 180) / 360) * W * newZoom;
  cam.y = H / 2 - ((90 - lat) / 180) * H * newZoom;
  zoomedIn = true;
  // gather info on nearest nation
  if (typeof openModal === 'function') {
    let nearest = null;
    let minDist = Infinity;
    for (const nn of nations) {
      const d = Math.hypot((nn.lon || 0) - lon, (nn.lat || 0) - lat);
      if (d < minDist) { minDist = d; nearest = nn; }
    }
    if (nearest) {
      // Build a list of informational lines for the region modal.  Basic demographics are always shown,
      // while sensitive military and resource data require active satellite surveillance on the target nation.
      // This implements a fog‑of‑war effect for the zoomable map.
      const lines = [];
      lines.push(`<strong>${nearest.name}</strong>`);
      if (nearest.leader) lines.push(`Leader: ${nearest.leader}`);
      if (nearest.doctrine) lines.push(`Doctrine: ${nearest.doctrine}`);
      lines.push(`Population: ${Math.floor(nearest.population || 0)}M`);
      lines.push(`Cities: ${nearest.cities || 0}`);
      lines.push(`Instability: ${Math.floor(nearest.instability || 0)}`);
      // Check if the player has a satellite covering this nation; if not, do not reveal sensitive information.
      const currentPlayer = PlayerManager.get();
      const hasIntelCoverage = currentPlayer && currentPlayer.satellites && currentPlayer.satellites[nearest.id];
      if (hasIntelCoverage) {
        lines.push(`Missiles: ${nearest.missiles || 0}, Defense: ${nearest.defense || 0}`);
        lines.push(`Production: ${Math.floor(nearest.production || 0)}, Uranium: ${Math.floor(nearest.uranium || 0)}, Intel: ${Math.floor(nearest.intel || 0)}`);
      } else {
        lines.push(`Surveillance required to view military and resource data`);
      }
      const info = `<div style="margin:8px 0">${lines.join('<br>')}</div>`;
      openModal(`${nearest.name} REGION`, info);
    }
  }
});

/// ============ INITIALIZATION ============

async function init() {
  try{ AudioSys.init(); }catch(e){}
  await loadWorld();
  // After the world has loaded and the camera is fully defined, run
  // resizeCanvas() again so the camera zoom adjusts to the actual
  // window dimensions.  Without this call the initial resizeCanvas()
  // invocation runs before 'cam' exists and skips the zoom scaling.
  resizeCanvas();
  animateStartScreen();
}
init();

// ============ GLOBAL EXPORTS FOR INLINE HANDLERS ============
window.applyTheme = applyTheme;
window.closeModal = closeModal;
window.startGame = startGame;
window.AudioSys = AudioSys;
window.Storage = Storage;
window.showOptionsModal = showOptionsModal;
window.quitToTitle = quitToTitle;
window.selectLeader = selectLeader;
</script>

<!-- Extend AI banter lines from external package.  This script attaches 
     additional phrases to window.aiBanterLines without overriding existing functionality. -->
<script defer src="norad-banter-pack-XL.js"></script>

</body>
</html>